# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rspec-expectations` gem.
# Please instead update this file by running `bin/tapioca gem rspec-expectations`.

# RSpec's top level namespace. All of rspec-expectations is contained
# in the `RSpec::Expectations` and `RSpec::Matchers` namespaces.
module RSpec
  class << self
    # Used to ensure examples get reloaded between multiple runs in the same
    # process and ensures user configuration is persisted.
    #
    # Users must invoke this if they want to clear all examples but preserve
    # current configuration when they use the runner multiple times within the
    # same process.
    def clear_examples; end

    # Returns the global [Configuration](RSpec/Core/Configuration) object. While
    # you _can_ use this method to access the configuration, the more common
    # convention is to use [RSpec.configure](RSpec#configure-class_method).
    #
    # @example
    #   RSpec.configuration.drb_port = 1234
    # @see RSpec.configure
    # @see Core::Configuration
    def configuration; end

    # Setters for shared global objects
    #
    # @api private
    def configuration=(_arg0); end

    # Yields the global configuration to a block.
    #
    # @example
    #   RSpec.configure do |config|
    #   config.add_formatter 'documentation'
    #   end
    # @see Core::Configuration
    # @yield [Configuration] global configuration
    def configure; end

    # @private
    def const_missing(name); end

    def context(*args, &example_group_block); end

    # The example being executed.
    #
    # The primary audience for this method is library authors who need access
    # to the example currently being executed and also want to support all
    # versions of RSpec 2 and 3.
    #
    # @example
    #
    #   RSpec.configure do |c|
    #   # context.example is deprecated, but RSpec.current_example is not
    #   # available until RSpec 3.0.
    #   fetch_current_example = RSpec.respond_to?(:current_example) ?
    #   proc { RSpec.current_example } : proc { |context| context.example }
    #
    #   c.before(:example) do
    #   example = fetch_current_example.call(self)
    #
    #   # ...
    #   end
    #   end
    def current_example; end

    # Set the current example being executed.
    #
    # @api private
    def current_example=(example); end

    # Get the current RSpec execution scope
    #
    # Returns (in order of lifecycle):
    #   * `:suite` as an initial value, this is outside of the test lifecycle.
    #   * `:before_suite_hook` during `before(:suite)` hooks.
    #   * `:before_context_hook` during `before(:context)` hooks.
    #   * `:before_example_hook` during `before(:example)` hooks and `around(:example)` before `example.run`.
    #   * `:example` within the example run.
    #   * `:after_example_hook` during `after(:example)` hooks and `around(:example)` after `example.run`.
    #   * `:after_context_hook` during `after(:context)` hooks.
    #   * `:after_suite_hook` during `after(:suite)` hooks.
    #   * `:suite` as a final value, again this is outside of the test lifecycle.
    #
    # Reminder, `:context` hooks have `:all` alias and `:example` hooks have `:each` alias.
    #
    # @return [Symbol]
    def current_scope; end

    # Set the current scope rspec is executing in
    #
    # @api private
    def current_scope=(scope); end

    def describe(*args, &example_group_block); end
    def example_group(*args, &example_group_block); end
    def fcontext(*args, &example_group_block); end
    def fdescribe(*args, &example_group_block); end

    # Used to ensure examples get reloaded and user configuration gets reset to
    # defaults between multiple runs in the same process.
    #
    # Users must invoke this if they want to have the configuration reset when
    # they use the runner multiple times within the same process. Users must deal
    # themselves with re-configuration of RSpec before run.
    def reset; end

    def shared_context(name, *args, &block); end
    def shared_examples(name, *args, &block); end
    def shared_examples_for(name, *args, &block); end

    # Internal container for global non-configuration data.
    #
    # @private
    def world; end

    # Setters for shared global objects
    #
    # @api private
    def world=(_arg0); end

    def xcontext(*args, &example_group_block); end
    def xdescribe(*args, &example_group_block); end
  end
end

# RSpec::Expectations provides a simple, readable API to express
# the expected outcomes in a code example. To express an expected
# outcome, wrap an object or block in `expect`, call `to` or `to_not`
# (aliased as `not_to`) and pass it a matcher object:
#
#     expect(order.total).to eq(Money.new(5.55, :USD))
#     expect(list).to include(user)
#     expect(message).not_to match(/foo/)
#     expect { do_something }.to raise_error
#
# The last form (the block form) is needed to match against ruby constructs
# that are not objects, but can only be observed when executing a block
# of code. This includes raising errors, throwing symbols, yielding,
# and changing values.
#
# When `expect(...).to` is invoked with a matcher, it turns around
# and calls `matcher.matches?(<object wrapped by expect>)`.  For example,
# in the expression:
#
#     expect(order.total).to eq(Money.new(5.55, :USD))
#
# ...`eq(Money.new(5.55, :USD))` returns a matcher object, and it results
# in the equivalent of `eq.matches?(order.total)`. If `matches?` returns
# `true`, the expectation is met and execution continues. If `false`, then
# the spec fails with the message returned by `eq.failure_message`.
#
# Given the expression:
#
#     expect(order.entries).not_to include(entry)
#
# ...the `not_to` method (also available as `to_not`) invokes the equivalent of
# `include.matches?(order.entries)`, but it interprets `false` as success, and
# `true` as a failure, using the message generated by
# `include.failure_message_when_negated`.
#
# rspec-expectations ships with a standard set of useful matchers, and writing
# your own matchers is quite simple.
#
# See [RSpec::Matchers](../RSpec/Matchers) for more information about the
# built-in matchers that ship with rspec-expectations, and how to write your
# own custom matchers.
module RSpec::Expectations
  class << self
    # The configuration object.
    #
    # @return [RSpec::Expectations::Configuration] the configuration object
    def configuration; end

    # @private
    def differ; end

    # Raises an RSpec::Expectations::ExpectationNotMetError with message.
    # Adds a diff to the failure message when `expected` and `actual` are
    # both present.
    #
    # @param message [String]
    # @param expected [Object]
    # @param actual [Object]
    def fail_with(message, expected = T.unsafe(nil), actual = T.unsafe(nil)); end
  end
end

# Validates the provided matcher to ensure it supports block
# expectations, in order to avoid user confusion when they
# use a block thinking the expectation will be on the return
# value of the block rather than the block itself.
#
# @private
class RSpec::Expectations::BlockExpectationTarget < ::RSpec::Expectations::ExpectationTarget
  def not_to(matcher, message = T.unsafe(nil), &block); end
  def to(matcher, message = T.unsafe(nil), &block); end
  def to_not(matcher, message = T.unsafe(nil), &block); end

  private

  # @raise [ExpectationNotMetError]
  def enforce_block_expectation(matcher); end

  # @return [Boolean]
  def supports_block_expectations?(matcher); end
end

# @private
class RSpec::Expectations::BlockSnippetExtractor
  # @return [BlockSnippetExtractor] a new instance of BlockSnippetExtractor
  def initialize(proc, method_name); end

  # Ideally we should properly handle indentations of multiline snippet,
  # but it's not implemented yet since because we use result of this method only when it's a
  # single line and implementing the logic introduces additional complexity.
  def body_content_lines; end

  # rubocop should properly handle `Struct.new {}` as an inner class definition.
  def method_name; end

  # rubocop should properly handle `Struct.new {}` as an inner class definition.
  def proc; end

  private

  def beginning_line_number; end
  def block_token_extractor; end
  def file_path; end
  def raw_body_lines; end
  def raw_body_snippet; end

  # @raise [TargetNotFoundError]
  def source; end

  def source_location; end

  class << self
    def try_extracting_single_line_body_of(proc, method_name); end
  end
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError < ::RSpec::Expectations::BlockSnippetExtractor::Error; end

# Locates target block with node information (semantics), which tokens don't have.
#
# @private
class RSpec::Expectations::BlockSnippetExtractor::BlockLocator < ::Struct
  # Returns the value of attribute beginning_line_number
  #
  # @return [Object] the current value of beginning_line_number
  def beginning_line_number; end

  # Sets the attribute beginning_line_number
  #
  # @param value [Object] the value to set the attribute beginning_line_number to.
  # @return [Object] the newly set value
  def beginning_line_number=(_); end

  def body_content_locations; end
  def method_call_location; end

  # Returns the value of attribute method_name
  #
  # @return [Object] the current value of method_name
  def method_name; end

  # Sets the attribute method_name
  #
  # @param value [Object] the value to set the attribute method_name to.
  # @return [Object] the newly set value
  def method_name=(_); end

  # Returns the value of attribute source
  #
  # @return [Object] the current value of source
  def source; end

  # Sets the attribute source
  #
  # @param value [Object] the value to set the attribute source to.
  # @return [Object] the newly set value
  def source=(_); end

  private

  def block_body_node; end
  def block_wrapper_node; end
  def candidate_block_wrapper_nodes; end
  def candidate_method_ident_nodes; end
  def method_ident_node; end

  # @return [Boolean]
  def method_ident_node?(node); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Performs extraction of block body snippet using tokens,
# which cannot be done with node information.
#
# @private
class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor < ::Struct
  # @return [BlockTokenExtractor] a new instance of BlockTokenExtractor
  def initialize(*_arg0); end

  # Returns the value of attribute beginning_line_number
  #
  # @return [Object] the current value of beginning_line_number
  def beginning_line_number; end

  # Sets the attribute beginning_line_number
  #
  # @param value [Object] the value to set the attribute beginning_line_number to.
  # @return [Object] the newly set value
  def beginning_line_number=(_); end

  # Returns the value of attribute body_tokens.
  def body_tokens; end

  # Returns the value of attribute method_name
  #
  # @return [Object] the current value of method_name
  def method_name; end

  # Sets the attribute method_name
  #
  # @param value [Object] the value to set the attribute method_name to.
  # @return [Object] the newly set value
  def method_name=(_); end

  # Returns the value of attribute source
  #
  # @return [Object] the current value of source
  def source; end

  # Sets the attribute source
  #
  # @param value [Object] the value to set the attribute source to.
  # @return [Object] the newly set value
  def source=(_); end

  # Returns the value of attribute state.
  def state; end

  private

  def after_beginning_of_args_state(token); end
  def after_beginning_of_body_state(token); end
  def after_method_call_state(token); end
  def after_opener_state(token); end
  def block_locator; end

  # @return [Boolean]
  def correct_block?(body_tokens); end

  def finalize_pending_tokens!; end
  def finish!; end
  def finish_or_find_next_block_if_incorrect!; end
  def handle_closer_token(token); end
  def handle_opener_token(token); end
  def initial_state(token); end
  def invoke_state_handler(token); end

  # @return [Boolean]
  def opener_token?(token); end

  def opener_token_stack; end
  def parse!; end
  def pending_tokens; end

  # @return [Boolean]
  def pipe_token?(token); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RSpec::Expectations::BlockSnippetExtractor::Error < ::StandardError; end
class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError < ::RSpec::Expectations::BlockSnippetExtractor::Error; end

# Provides configuration options for rspec-expectations.
# If you are using rspec-core, you can access this via a
# block passed to `RSpec::Core::Configuration#expect_with`.
# Otherwise, you can access it via RSpec::Expectations.configuration.
#
# @example
#   RSpec.configure do |rspec|
#   rspec.expect_with :rspec do |c|
#   # c is the config object
#   end
#   end
#
#   # or
#
#   RSpec::Expectations.configuration
class RSpec::Expectations::Configuration
  # @return [Configuration] a new instance of Configuration
  def initialize; end

  # Adds `should` and `should_not` to the given classes
  # or modules. This can be used to ensure `should` works
  # properly on things like proxy objects (particular
  # `Delegator`-subclassed objects on 1.8).
  #
  # @param modules [Array<Module>] the list of classes or modules
  #   to add `should` and `should_not` to.
  def add_should_and_should_not_to(*modules); end

  # Sets or gets the backtrace formatter. The backtrace formatter should
  # implement `#format_backtrace(Array<String>)`. This is used
  # to format backtraces of errors handled by the `raise_error`
  # matcher.
  #
  # If you are using rspec-core, rspec-core's backtrace formatting
  # will be used (including respecting the presence or absence of
  # the `--backtrace` option).
  def backtrace_formatter; end

  # Sets or gets the backtrace formatter. The backtrace formatter should
  # implement `#format_backtrace(Array<String>)`. This is used
  # to format backtraces of errors handled by the `raise_error`
  # matcher.
  #
  # If you are using rspec-core, rspec-core's backtrace formatting
  # will be used (including respecting the presence or absence of
  # the `--backtrace` option).
  def backtrace_formatter=(_arg0); end

  # Indicates whether or not diffs should be colored.
  # Delegates to rspec-core's color option if rspec-core
  # is loaded; otherwise you can set it here.
  #
  # @return [Boolean]
  def color?; end

  # @private
  def false_positives_handler; end

  # Sets if custom matcher descriptions and failure messages
  # should include clauses from methods defined using `chain`.
  #
  # @param value [Boolean]
  def include_chain_clauses_in_custom_matcher_descriptions=(_arg0); end

  # Indicates whether or not custom matcher descriptions and failure messages
  # should include clauses from methods defined using `chain`. It is
  # false by default for backwards compatibility.
  #
  # @return [Boolean]
  def include_chain_clauses_in_custom_matcher_descriptions?; end

  # Configures the maximum character length that RSpec will print while
  # formatting an object. You can set length to nil to prevent RSpec from
  # doing truncation.
  #
  # @example
  #   RSpec.configure do |rspec|
  #   rspec.expect_with :rspec do |c|
  #   c.max_formatted_output_length = 200
  #   end
  #   end
  # @param length [Fixnum] the number of characters to limit the formatted output to.
  def max_formatted_output_length=(length); end

  # Indicates what RSpec will do about matcher use which will
  # potentially cause false positives in tests, generally you want to
  # avoid such scenarios so this defaults to `true`.
  def on_potential_false_positives; end

  # Configures what RSpec will do about matcher use which will
  # potentially cause false positives in tests.
  #
  # @param behavior [Symbol] can be set to :warn, :raise or :nothing
  def on_potential_false_positives=(behavior); end

  # @private
  def reset_syntaxes_to_default; end

  # Returns the value of attribute strict_predicate_matchers.
  def strict_predicate_matchers; end

  # Configures RSpec to check predicate matchers to `be(true)` / `be(false)` (strict),
  # or `be_truthy` / `be_falsey` (not strict).
  # Historically, the default was `false`, but `true` is recommended.
  #
  # @raise [ArgumentError]
  def strict_predicate_matchers=(flag); end

  # @return [Boolean]
  def strict_predicate_matchers?; end

  # The list of configured syntaxes.
  #
  # @example
  #   unless RSpec::Matchers.configuration.syntax.include?(:expect)
  #   raise "this RSpec extension gem requires the rspec-expectations `:expect` syntax"
  #   end
  # @return [Array<Symbol>] the list of configured syntaxes.
  def syntax; end

  # Configures the supported syntax.
  #
  # @example
  #   RSpec.configure do |rspec|
  #   rspec.expect_with :rspec do |c|
  #   c.syntax = :should
  #   # or
  #   c.syntax = :expect
  #   # or
  #   c.syntax = [:should, :expect]
  #   end
  #   end
  # @param values [Array<Symbol>, Symbol] the syntaxes to enable
  def syntax=(values); end

  # Configures whether RSpec will warn about matcher use which will
  # potentially cause false positives in tests.
  #
  # @param boolean [Boolean]
  def warn_about_potential_false_positives=(boolean); end

  # Indicates whether RSpec will warn about matcher use which will
  # potentially cause false positives in tests, generally you want to
  # avoid such scenarios so this defaults to `true`.
  #
  # @return [Boolean]
  def warn_about_potential_false_positives?; end
end

# @private
RSpec::Expectations::Configuration::FALSE_POSITIVE_BEHAVIOURS = T.let(T.unsafe(nil), Hash)

# Null implementation of a backtrace formatter used by default
# when rspec-core is not loaded. Does no filtering.
#
# @api private
module RSpec::Expectations::Configuration::NullBacktraceFormatter
  class << self
    def format_backtrace(backtrace); end
  end
end

# @private
module RSpec::Expectations::ExpectationHelper
  class << self
    def check_message(msg); end
    def handle_failure(matcher, message, failure_message_method); end

    # Returns an RSpec-3+ compatible matcher, wrapping a legacy one
    # in an adapter if necessary.
    #
    # @private
    def modern_matcher_from(matcher); end

    def with_matcher(handler, matcher, message); end
  end
end

# Exception raised when an expectation fails.
#
# the user sets an expectation, it can't be caught in their
# code by a bare `rescue`.
#
# @api public
# @note We subclass Exception so that in a stub implementation if
class RSpec::Expectations::ExpectationNotMetError < ::Exception; end

# Wraps the target of an expectation.
#
# @example
#   expect(something)       # => ExpectationTarget wrapping something
#   expect { do_something } # => ExpectationTarget wrapping the block
#
#   # used with `to`
#   expect(actual).to eq(3)
#
#   # with `not_to`
#   expect(actual).not_to eq(3)
# @note `ExpectationTarget` is not intended to be instantiated
#   directly by users. Use `expect` instead.
class RSpec::Expectations::ExpectationTarget
  include ::RSpec::Expectations::ExpectationTarget::InstanceMethods

  # @api private
  # @return [ExpectationTarget] a new instance of ExpectationTarget
  def initialize(value); end

  # @note this name aligns with `Minitest::Expectation` so that our
  #   {InstanceMethods} module can be included in that class when
  #   used in a Minitest context.
  # @return [Object] the target of the expectation
  def target; end

  class << self
    # @private
    def for(value, block); end
  end
end

# Defines instance {ExpectationTarget} instance methods. These are defined
# in a module so we can include it in `Minitest::Expectation` when
# `rspec/expectations/minitest_integration` is loaded in order to
# support usage with Minitest.
module RSpec::Expectations::ExpectationTarget::InstanceMethods
  # Runs the given expectation, passing if `matcher` returns false.
  #
  # @example
  #   expect(value).not_to eq(5)
  # @param matcher [Matcher]
  # @param message [String, Proc] optional message to display when the expectation fails
  # @return [Boolean] false if the negative expectation succeeds (else raises)
  # @see RSpec::Matchers
  def not_to(matcher = T.unsafe(nil), message = T.unsafe(nil), &block); end

  # Runs the given expectation, passing if `matcher` returns true.
  #
  # @example
  #   expect(value).to eq(5)
  #   expect { perform }.to raise_error
  # @param matcher [Matcher]
  # @param message [String, Proc] optional message to display when the expectation fails
  # @return [Boolean] true if the expectation succeeds (else raises)
  # @see RSpec::Matchers
  def to(matcher = T.unsafe(nil), message = T.unsafe(nil), &block); end

  # Runs the given expectation, passing if `matcher` returns false.
  #
  # @example
  #   expect(value).not_to eq(5)
  # @param matcher [Matcher]
  # @param message [String, Proc] optional message to display when the expectation fails
  # @return [Boolean] false if the negative expectation succeeds (else raises)
  # @see RSpec::Matchers
  def to_not(matcher = T.unsafe(nil), message = T.unsafe(nil), &block); end

  private

  # @raise [ArgumentError]
  def prevent_operator_matchers(verb); end
end

# Used as a sentinel value to be able to tell when the user
# did not pass an argument. We can't use `nil` for that because
# `nil` is a valid value to pass.
#
# @private
module RSpec::Expectations::ExpectationTarget::UndefinedValue; end

# @private
class RSpec::Expectations::FailureAggregator
  # @return [FailureAggregator] a new instance of FailureAggregator
  def initialize(block_label, metadata); end

  def aggregate; end

  # Returns the value of attribute block_label.
  def block_label; end

  # This method is defined to satisfy the callable interface
  # expected by `RSpec::Support.with_failure_notifier`.
  def call(failure, options); end

  def failures; end

  # Returns the value of attribute metadata.
  def metadata; end

  def other_errors; end

  private

  # Using `caller` performs better (and is simpler) than `raise` on most Rubies.
  def assign_backtrace(failure); end

  def notify_aggregated_failures; end
end

# RSpec 3.0 was released with the class name misspelled. For SemVer compatibility,
# we will provide this misspelled alias until 4.0.
#
# @deprecated Use LegacyMatcherAdapter instead.
# @private
RSpec::Expectations::LegacyMacherAdapter = RSpec::Expectations::LegacyMatcherAdapter

# Wraps a matcher written against one of the legacy protocols in
# order to present the current protocol.
#
# @private
class RSpec::Expectations::LegacyMatcherAdapter < ::RSpec::Matchers::MatcherDelegator
  # @return [LegacyMatcherAdapter] a new instance of LegacyMatcherAdapter
  def initialize(matcher); end

  class << self
    def wrap(matcher); end
  end
end

# Before RSpec 1.2, the failure message protocol was:
#   * `failure_message`
#   * `negative_failure_message`
#
# @private
class RSpec::Expectations::LegacyMatcherAdapter::RSpec1 < ::RSpec::Expectations::LegacyMatcherAdapter
  def failure_message; end
  def failure_message_when_negated; end

  class << self
    # Note: `failure_message` is part of the RSpec 3 protocol
    # (paired with `failure_message_when_negated`), so we don't check
    # for `failure_message` here.
    #
    # @return [Boolean]
    def interface_matches?(matcher); end
  end
end

# Starting in RSpec 1.2 (and continuing through all 2.x releases),
# the failure message protocol was:
#   * `failure_message_for_should`
#   * `failure_message_for_should_not`
#
# @private
class RSpec::Expectations::LegacyMatcherAdapter::RSpec2 < ::RSpec::Expectations::LegacyMatcherAdapter
  def failure_message; end
  def failure_message_when_negated; end

  class << self
    # @return [Boolean]
    def interface_matches?(matcher); end
  end
end

# Exception raised from `aggregate_failures` when multiple expectations fail.
#
# @note The constant is defined here but the extensive logic of this class
#   is lazily defined when `FailureAggregator` is autoloaded, since we do
#   not need to waste time defining that functionality unless
#   `aggregate_failures` is used.
class RSpec::Expectations::MultipleExpectationsNotMetError < ::RSpec::Expectations::ExpectationNotMetError
  # @return [MultipleExpectationsNotMetError] a new instance of MultipleExpectationsNotMetError
  def initialize(failure_aggregator); end

  # @return [String] The user-assigned label for the aggregation block.
  def aggregation_block_label; end

  # @return [Hash] The metadata hash passed to `aggregate_failures`.
  def aggregation_metadata; end

  # @return [Array<Exception>] The list of expectation failures and other exceptions, combined.
  def all_exceptions; end

  # return [String] A description of the failure/error counts.
  def exception_count_description; end

  # @return [Array<RSpec::Expectations::ExpectationNotMetError>] The list of expectation failures.
  def failures; end

  # @return [String] The fully formatted exception message.
  def message; end

  # @return [Array<Exception>] The list of other exceptions.
  def other_errors; end

  # @return [String] A summary of the failure, including the block label and a count of failures.
  def summary; end

  private

  def backtrace_line(line); end
  def block_description; end
  def enumerated(exceptions, index_offset); end
  def enumerated_errors; end
  def enumerated_failures; end
  def exclusion_patterns; end
  def format_backtrace(backtrace); end
  def indentation; end
  def indented(failure_message, index); end
  def index_label(index); end
  def longest_index_label_width; end
  def pluralize(noun, count); end
  def width_of_label(index); end
end

# @private
class RSpec::Expectations::NegativeExpectationHandler
  class << self
    # @return [Boolean]
    def does_not_match?(matcher, actual, &block); end

    def handle_matcher(actual, initial_matcher, custom_message = T.unsafe(nil), &block); end
    def opposite_should_method; end
    def should_method; end
    def verb; end
  end
end

# @private
class RSpec::Expectations::PositiveExpectationHandler
  class << self
    def handle_matcher(actual, initial_matcher, custom_message = T.unsafe(nil), &block); end
    def opposite_should_method; end
    def should_method; end
    def verb; end
  end
end

# Provides methods for enabling and disabling the available
# syntaxes provided by rspec-expectations.
#
# @api private
module RSpec::Expectations::Syntax
  private

  # Determines where we add `should` and `should_not`.
  #
  # @api private
  def default_should_host; end

  # Disables the `expect` syntax.
  #
  # @api private
  def disable_expect(syntax_host = T.unsafe(nil)); end

  # Disables the `should` syntax.
  #
  # @api private
  def disable_should(syntax_host = T.unsafe(nil)); end

  # Enables the `expect` syntax.
  #
  # @api private
  def enable_expect(syntax_host = T.unsafe(nil)); end

  # Enables the `should` syntax.
  #
  # @api private
  def enable_should(syntax_host = T.unsafe(nil)); end

  # Indicates whether or not the `expect` syntax is enabled.
  #
  # @api private
  def expect_enabled?(syntax_host = T.unsafe(nil)); end

  # Indicates whether or not the `should` syntax is enabled.
  #
  # @api private
  def should_enabled?(syntax_host = T.unsafe(nil)); end

  # Instructs rspec-expectations to warn on first usage of `should` or `should_not`.
  # Enabled by default. This is largely here to facilitate testing.
  #
  # @api private
  def warn_about_should!; end

  # Generates a deprecation warning for the given method if no warning
  # has already been issued.
  #
  # @api private
  def warn_about_should_unless_configured(method_name); end

  class << self
    # Determines where we add `should` and `should_not`.
    #
    # @api private
    def default_should_host; end

    # Disables the `expect` syntax.
    #
    # @api private
    def disable_expect(syntax_host = T.unsafe(nil)); end

    # Disables the `should` syntax.
    #
    # @api private
    def disable_should(syntax_host = T.unsafe(nil)); end

    # Enables the `expect` syntax.
    #
    # @api private
    def enable_expect(syntax_host = T.unsafe(nil)); end

    # Enables the `should` syntax.
    #
    # @api private
    def enable_should(syntax_host = T.unsafe(nil)); end

    # Indicates whether or not the `expect` syntax is enabled.
    #
    # @api private
    # @return [Boolean]
    def expect_enabled?(syntax_host = T.unsafe(nil)); end

    # Indicates whether or not the `should` syntax is enabled.
    #
    # @api private
    # @return [Boolean]
    def should_enabled?(syntax_host = T.unsafe(nil)); end

    # Instructs rspec-expectations to warn on first usage of `should` or `should_not`.
    # Enabled by default. This is largely here to facilitate testing.
    #
    # @api private
    def warn_about_should!; end

    # Generates a deprecation warning for the given method if no warning
    # has already been issued.
    #
    # @api private
    def warn_about_should_unless_configured(method_name); end
  end
end

# Validates the provided matcher to ensure it supports block
# expectations, in order to avoid user confusion when they
# use a block thinking the expectation will be on the return
# value of the block rather than the block itself.
#
# @private
class RSpec::Expectations::ValueExpectationTarget < ::RSpec::Expectations::ExpectationTarget
  def not_to(matcher = T.unsafe(nil), message = T.unsafe(nil), &block); end
  def to(matcher = T.unsafe(nil), message = T.unsafe(nil), &block); end

  private

  def enforce_value_expectation(matcher); end

  # @return [Boolean]
  def supports_value_expectations?(matcher); end
end

# @private
module RSpec::Expectations::Version; end

RSpec::Expectations::Version::STRING = T.let(T.unsafe(nil), String)

# @private
RSpec::MODULES_TO_AUTOLOAD = T.let(T.unsafe(nil), Hash)

# RSpec::Matchers provides a number of useful matchers we use to define
# expectations. Any object that implements the [matcher protocol](Matchers/MatcherProtocol)
# can be used as a matcher.
#
# ## Predicates
#
# In addition to matchers that are defined explicitly, RSpec will create
# custom matchers on the fly for any arbitrary predicate, giving your specs a
# much more natural language feel.
#
# A Ruby predicate is a method that ends with a "?" and returns true or false.
# Common examples are `empty?`, `nil?`, and `instance_of?`.
#
# All you need to do is write `expect(..).to be_` followed by the predicate
# without the question mark, and RSpec will figure it out from there.
# For example:
#
#     expect([]).to be_empty     # => [].empty?() | passes
#     expect([]).not_to be_empty # => [].empty?() | fails
#
# In addtion to prefixing the predicate matchers with "be_", you can also use "be_a_"
# and "be_an_", making your specs read much more naturally:
#
#     expect("a string").to be_an_instance_of(String) # =>"a string".instance_of?(String) # passes
#
#     expect(3).to be_a_kind_of(Integer)          # => 3.kind_of?(Numeric)     | passes
#     expect(3).to be_a_kind_of(Numeric)          # => 3.kind_of?(Numeric)     | passes
#     expect(3).to be_an_instance_of(Integer)     # => 3.instance_of?(Integer) | passes
#     expect(3).not_to be_an_instance_of(Numeric) # => 3.instance_of?(Numeric) | fails
#
# RSpec will also create custom matchers for predicates like `has_key?`. To
# use this feature, just state that the object should have_key(:key) and RSpec will
# call has_key?(:key) on the target. For example:
#
#     expect(:a => "A").to have_key(:a)
#     expect(:a => "A").to have_key(:b) # fails
#
# You can use this feature to invoke any predicate that begins with "has_", whether it is
# part of the Ruby libraries (like `Hash#has_key?`) or a method you wrote on your own class.
#
# Note that RSpec does not provide composable aliases for these dynamic predicate
# matchers. You can easily define your own aliases, though:
#
#     RSpec::Matchers.alias_matcher :a_user_who_is_an_admin, :be_an_admin
#     expect(user_list).to include(a_user_who_is_an_admin)
#
# ## Alias Matchers
#
# With {RSpec::Matchers.alias_matcher}, you can easily create an
# alternate name for a given matcher.
#
# The description will also change according to the new name:
#
#     RSpec::Matchers.alias_matcher :a_list_that_sums_to, :sum_to
#     sum_to(3).description # => "sum to 3"
#     a_list_that_sums_to(3).description # => "a list that sums to 3"
#
# or you can specify a custom description like this:
#
#     RSpec::Matchers.alias_matcher :a_list_sorted_by, :be_sorted_by do |description|
#       description.sub("be sorted by", "a list sorted by")
#     end
#
#     be_sorted_by(:age).description # => "be sorted by age"
#     a_list_sorted_by(:age).description # => "a list sorted by age"
#
# ## Custom Matchers
#
# When you find that none of the stock matchers provide a natural feeling
# expectation, you can very easily write your own using RSpec's matcher DSL
# or writing one from scratch.
#
# ### Matcher DSL
#
# Imagine that you are writing a game in which players can be in various
# zones on a virtual board. To specify that bob should be in zone 4, you
# could say:
#
#     expect(bob.current_zone).to eql(Zone.new("4"))
#
# But you might find it more expressive to say:
#
#     expect(bob).to be_in_zone("4")
#
# and/or
#
#     expect(bob).not_to be_in_zone("3")
#
# You can create such a matcher like so:
#
#     RSpec::Matchers.define :be_in_zone do |zone|
#       match do |player|
#         player.in_zone?(zone)
#       end
#     end
#
# This will generate a <tt>be_in_zone</tt> method that returns a matcher
# with logical default messages for failures. You can override the failure
# messages and the generated description as follows:
#
#     RSpec::Matchers.define :be_in_zone do |zone|
#       match do |player|
#         player.in_zone?(zone)
#       end
#
#       failure_message do |player|
#         # generate and return the appropriate string.
#       end
#
#       failure_message_when_negated do |player|
#         # generate and return the appropriate string.
#       end
#
#       description do
#         # generate and return the appropriate string.
#       end
#     end
#
# Each of the message-generation methods has access to the block arguments
# passed to the <tt>create</tt> method (in this case, <tt>zone</tt>). The
# failure message methods (<tt>failure_message</tt> and
# <tt>failure_message_when_negated</tt>) are passed the actual value (the
# receiver of <tt>expect(..)</tt> or <tt>expect(..).not_to</tt>).
#
# ### Custom Matcher from scratch
#
# You could also write a custom matcher from scratch, as follows:
#
#     class BeInZone
#       def initialize(expected)
#         @expected = expected
#       end
#
#       def matches?(target)
#         @target = target
#         @target.current_zone.eql?(Zone.new(@expected))
#       end
#
#       def failure_message
#         "expected #{@target.inspect} to be in Zone #{@expected}"
#       end
#
#       def failure_message_when_negated
#         "expected #{@target.inspect} not to be in Zone #{@expected}"
#       end
#     end
#
# ... and a method like this:
#
#     def be_in_zone(expected)
#       BeInZone.new(expected)
#     end
#
# And then expose the method to your specs. This is normally done
# by including the method and the class in a module, which is then
# included in your spec:
#
#     module CustomGameMatchers
#       class BeInZone
#         # ...
#       end
#
#       def be_in_zone(expected)
#         # ...
#       end
#     end
#
#     describe "Player behaviour" do
#       include CustomGameMatchers
#       # ...
#     end
#
# or you can include in globally in a spec_helper.rb file <tt>require</tt>d
# from your spec file(s):
#
#     RSpec::configure do |config|
#       config.include(CustomGameMatchers)
#     end
#
# ### Making custom matchers composable
#
# RSpec's built-in matchers are designed to be composed, in expressions like:
#
#     expect(["barn", 2.45]).to contain_exactly(
#       a_value_within(0.1).of(2.5),
#       a_string_starting_with("bar")
#     )
#
# Custom matchers can easily participate in composed matcher expressions like these.
# Include {RSpec::Matchers::Composable} in your custom matcher to make it support
# being composed (matchers defined using the DSL have this included automatically).
# Within your matcher's `matches?` method (or the `match` block, if using the DSL),
# use `values_match?(expected, actual)` rather than `expected == actual`.
# Under the covers, `values_match?` is able to match arbitrary
# nested data structures containing a mix of both matchers and non-matcher objects.
# It uses `===` and `==` to perform the matching, considering the values to
# match if either returns `true`. The `Composable` mixin also provides some helper
# methods for surfacing the matcher descriptions within your matcher's description
# or failure messages.
#
# RSpec's built-in matchers each have a number of aliases that rephrase the matcher
# from a verb phrase (such as `be_within`) to a noun phrase (such as `a_value_within`),
# which reads better when the matcher is passed as an argument in a composed matcher
# expressions, and also uses the noun-phrase wording in the matcher's `description`,
# for readable failure messages. You can alias your custom matchers in similar fashion
# using {RSpec::Matchers.alias_matcher}.
#
# ## Negated Matchers
#
# Sometimes if you want to test for the opposite using a more descriptive name
# instead of using `not_to`, you can use {RSpec::Matchers.define_negated_matcher}:
#
#     RSpec::Matchers.define_negated_matcher :exclude, :include
#     include(1, 2).description # => "include 1 and 2"
#     exclude(1, 2).description # => "exclude 1 and 2"
#
# While the most obvious negated form may be to add a `not_` prefix,
# the failure messages you get with that form can be confusing (e.g.
# "expected [actual] to not [verb], but did not"). We've found it works
# best to find a more positive name for the negated form, such as
# `avoid_changing` rather than `not_change`.
module RSpec::Matchers
  extend ::RSpec::Matchers::DSL

  # Applied to a proc, specifies that its execution will cause some value to
  # change.
  #
  # You can either pass <tt>receiver</tt> and <tt>message</tt>, or a block,
  # but not both.
  #
  # When passing a block, it must use the `{ ... }` format, not
  # do/end, as `{ ... }` binds to the `change` method, whereas do/end
  # would errantly bind to the `expect(..).to` or `expect(...).not_to` method.
  #
  # You can chain any of the following off of the end to specify details
  # about the change:
  #
  # * `from`
  # * `to`
  #
  # or any one of:
  #
  # * `by`
  # * `by_at_least`
  # * `by_at_most`
  #
  # == Notes
  #
  # Evaluates `receiver.message` or `block` before and after it
  # evaluates the block passed to `expect`. If the value is the same
  # object, its before/after `hash` value is used to see if it has changed.
  # Therefore, your object needs to properly implement `hash` to work correctly
  # with this matcher.
  #
  # `expect( ... ).not_to change` supports the form that specifies `from`
  # (which specifies what you expect the starting, unchanged value to be)
  # but does not support forms with subsequent calls to `by`, `by_at_least`,
  # `by_at_most` or `to`.
  #
  # @example
  #   expect {
  #   team.add_player(player)
  #   }.to change(roster, :count)
  #
  #   expect {
  #   team.add_player(player)
  #   }.to change(roster, :count).by(1)
  #
  #   expect {
  #   team.add_player(player)
  #   }.to change(roster, :count).by_at_least(1)
  #
  #   expect {
  #   team.add_player(player)
  #   }.to change(roster, :count).by_at_most(1)
  #
  #   string = "string"
  #   expect {
  #   string.reverse!
  #   }.to change { string }.from("string").to("gnirts")
  #
  #   string = "string"
  #   expect {
  #   string
  #   }.not_to change { string }.from("string")
  #
  #   expect {
  #   person.happy_birthday
  #   }.to change(person, :birthday).from(32).to(33)
  #
  #   expect {
  #   employee.develop_great_new_social_networking_app
  #   }.to change(employee, :title).from("Mail Clerk").to("CEO")
  #
  #   expect {
  #   doctor.leave_office
  #   }.to change(doctor, :sign).from(/is in/).to(/is out/)
  #
  #   user = User.new(:type => "admin")
  #   expect {
  #   user.symbolize_type
  #   }.to change(user, :type).from(String).to(Symbol)
  # @param receiver [Object]
  # @param message [Symbol] the message to send the receiver
  def a_block_changing(*args, &block); end

  # With no arg, passes if the block outputs `to_stdout` or `to_stderr`.
  # With a string, passes if the block outputs that specific string `to_stdout` or `to_stderr`.
  # With a regexp or matcher, passes if the block outputs a string `to_stdout` or `to_stderr` that matches.
  #
  # To capture output from any spawned subprocess as well, use `to_stdout_from_any_process` or
  # `to_stderr_from_any_process`. Output from any process that inherits the main process's corresponding
  # standard stream will be captured.
  #
  # @example
  #   expect { print 'foo' }.to output.to_stdout
  #   expect { print 'foo' }.to output('foo').to_stdout
  #   expect { print 'foo' }.to output(/foo/).to_stdout
  #
  #   expect { do_something }.to_not output.to_stdout
  #
  #   expect { warn('foo') }.to output.to_stderr
  #   expect { warn('foo') }.to output('foo').to_stderr
  #   expect { warn('foo') }.to output(/foo/).to_stderr
  #
  #   expect { do_something }.to_not output.to_stderr
  #
  #   expect { system('echo foo') }.to output("foo\n").to_stdout_from_any_process
  #   expect { system('echo foo', out: :err) }.to output("foo\n").to_stderr_from_any_process
  # @note `to_stdout` and `to_stderr` work by temporarily replacing `$stdout` or `$stderr`,
  #   so they're not able to intercept stream output that explicitly uses `STDOUT`/`STDERR`
  #   or that uses a reference to `$stdout`/`$stderr` that was stored before the
  #   matcher was used.
  # @note `to_stdout_from_any_process` and `to_stderr_from_any_process` use Tempfiles, and
  #   are thus significantly (~30x) slower than `to_stdout` and `to_stderr`.
  def a_block_outputting(*args, &block); end

  # With no args, matches if any error is raised.
  # With a named error, matches only if that specific error is raised.
  # With a named error and messsage specified as a String, matches only if both match.
  # With a named error and messsage specified as a Regexp, matches only if both match.
  # Pass an optional block to perform extra verifications on the exception matched
  #
  # @example
  #   expect { do_something_risky }.to raise_error
  #   expect { do_something_risky }.to raise_error(PoorRiskDecisionError)
  #   expect { do_something_risky }.to raise_error(PoorRiskDecisionError) { |error| expect(error.data).to eq 42 }
  #   expect { do_something_risky }.to raise_error { |error| expect(error.data).to eq 42 }
  #   expect { do_something_risky }.to raise_error(PoorRiskDecisionError, "that was too risky")
  #   expect { do_something_risky }.to raise_error(PoorRiskDecisionError, /oo ri/)
  #   expect { do_something_risky }.to raise_error("that was too risky")
  #
  #   expect { do_something_risky }.not_to raise_error
  def a_block_raising(*args, &block); end

  # Given no argument, matches if a proc throws any Symbol.
  #
  # Given a Symbol, matches if the given proc throws the specified Symbol.
  #
  # Given a Symbol and an arg, matches if the given proc throws the
  # specified Symbol with the specified arg.
  #
  # @example
  #   expect { do_something_risky }.to throw_symbol
  #   expect { do_something_risky }.to throw_symbol(:that_was_risky)
  #   expect { do_something_risky }.to throw_symbol(:that_was_risky, 'culprit')
  #
  #   expect { do_something_risky }.not_to throw_symbol
  #   expect { do_something_risky }.not_to throw_symbol(:that_was_risky)
  #   expect { do_something_risky }.not_to throw_symbol(:that_was_risky, 'culprit')
  def a_block_throwing(*args, &block); end

  # Passes if the method called in the expect block yields, regardless
  # of whether or not arguments are yielded.
  #
  # @example
  #   expect { |b| 5.tap(&b) }.to yield_control
  #   expect { |b| "a".to_sym(&b) }.not_to yield_control
  # @note Your expect block must accept a parameter and pass it on to
  #   the method-under-test as a block.
  def a_block_yielding_control(*args, &block); end

  # Designed for use with methods that repeatedly yield (such as
  # iterators). Passes if the method called in the expect block yields
  # multiple times with arguments matching those given.
  #
  # Argument matching is done using `===` (the case match operator)
  # and `==`. If the expected and actual arguments match with either
  # operator, the matcher will pass.
  #
  # @example
  #   expect { |b| [1, 2, 3].each(&b) }.to yield_successive_args(1, 2, 3)
  #   expect { |b| { :a => 1, :b => 2 }.each(&b) }.to yield_successive_args([:a, 1], [:b, 2])
  #   expect { |b| [1, 2, 3].each(&b) }.not_to yield_successive_args(1, 2)
  # @note Your expect block must accept a parameter and pass it on to
  #   the method-under-test as a block.
  def a_block_yielding_successive_args(*args, &block); end

  # Given no arguments, matches if the method called in the expect
  # block yields with arguments (regardless of what they are or how
  # many there are).
  #
  # Given arguments, matches if the method called in the expect block
  # yields with arguments that match the given arguments.
  #
  # Argument matching is done using `===` (the case match operator)
  # and `==`. If the expected and actual arguments match with either
  # operator, the matcher will pass.
  #
  # @example
  #   expect { |b| 5.tap(&b) }.to yield_with_args # because #tap yields an arg
  #   expect { |b| 5.tap(&b) }.to yield_with_args(5) # because 5 == 5
  #   expect { |b| 5.tap(&b) }.to yield_with_args(Integer) # because Integer === 5
  #   expect { |b| File.open("f.txt", &b) }.to yield_with_args(/txt/) # because /txt/ === "f.txt"
  #
  #   expect { |b| User.transaction(&b) }.not_to yield_with_args # because it yields no args
  #   expect { |b| 5.tap(&b) }.not_to yield_with_args(1, 2, 3)
  # @note Your expect block must accept a parameter and pass it on to
  #   the method-under-test as a block.
  # @note This matcher is not designed for use with methods that yield
  #   multiple times.
  def a_block_yielding_with_args(*args, &block); end

  # Passes if the method called in the expect block yields with
  # no arguments. Fails if it does not yield, or yields with arguments.
  #
  # @example
  #   expect { |b| User.transaction(&b) }.to yield_with_no_args
  #   expect { |b| 5.tap(&b) }.not_to yield_with_no_args # because it yields with `5`
  #   expect { |b| "a".to_sym(&b) }.not_to yield_with_no_args # because it does not yield
  # @note Your expect block must accept a parameter and pass it on to
  #   the method-under-test as a block.
  # @note This matcher is not designed for use with methods that yield
  #   multiple times.
  def a_block_yielding_with_no_args(*args, &block); end

  # Passes if actual contains all of the expected regardless of order.
  # This works for collections. Pass in multiple args and it will only
  # pass if all args are found in collection.
  #
  # @example
  #   expect([1, 2, 3]).to contain_exactly(1, 2, 3)
  #   expect([1, 2, 3]).to contain_exactly(1, 3, 2)
  # @note This is also available using the `=~` operator with `should`,
  #   but `=~` is not supported with `expect`.
  # @see #match_array
  def a_collection_containing_exactly(*args, &block); end

  # Matches if the actual value ends with the expected value(s). In the case
  # of a string, matches against the last `expected.length` characters of the
  # actual string. In the case of an array, matches against the last
  # `expected.length` elements of the actual array.
  #
  # @example
  #   expect("this string").to   end_with "string"
  #   expect([0, 1, 2, 3, 4]).to end_with 4
  #   expect([0, 2, 3, 4, 4]).to end_with 3, 4
  def a_collection_ending_with(*args, &block); end

  # Passes if actual includes expected. This works for
  # collections and Strings. You can also pass in multiple args
  # and it will only pass if all args are found in collection.
  #
  # @example
  #   expect([1,2,3]).to      include(3)
  #   expect([1,2,3]).to      include(2,3)
  #   expect([1,2,3]).to      include(2,3,4) # fails
  #   expect([1,2,3]).not_to  include(4)
  #   expect("spread").to     include("read")
  #   expect("spread").not_to include("red")
  #   expect(:a => 1, :b => 2).to include(:a)
  #   expect(:a => 1, :b => 2).to include(:a, :b)
  #   expect(:a => 1, :b => 2).to include(:a => 1)
  #   expect(:a => 1, :b => 2).to include(:b => 2, :a => 1)
  #   expect(:a => 1, :b => 2).to include(:c) # fails
  #   expect(:a => 1, :b => 2).not_to include(:a => 2)
  def a_collection_including(*args, &block); end

  # Matches if the actual value starts with the expected value(s). In the
  # case of a string, matches against the first `expected.length` characters
  # of the actual string. In the case of an array, matches against the first
  # `expected.length` elements of the actual array.
  #
  # @example
  #   expect("this string").to   start_with "this s"
  #   expect([0, 1, 2, 3, 4]).to start_with 0
  #   expect([0, 2, 3, 4, 4]).to start_with 0, 1
  def a_collection_starting_with(*args, &block); end

  # Passes if actual is falsey (false or nil)
  def a_falsey_value(*args, &block); end

  # Passes if actual is falsey (false or nil)
  def a_falsy_value(*args, &block); end

  # Passes if actual includes expected. This works for
  # collections and Strings. You can also pass in multiple args
  # and it will only pass if all args are found in collection.
  #
  # @example
  #   expect([1,2,3]).to      include(3)
  #   expect([1,2,3]).to      include(2,3)
  #   expect([1,2,3]).to      include(2,3,4) # fails
  #   expect([1,2,3]).not_to  include(4)
  #   expect("spread").to     include("read")
  #   expect("spread").not_to include("red")
  #   expect(:a => 1, :b => 2).to include(:a)
  #   expect(:a => 1, :b => 2).to include(:a, :b)
  #   expect(:a => 1, :b => 2).to include(:a => 1)
  #   expect(:a => 1, :b => 2).to include(:b => 2, :a => 1)
  #   expect(:a => 1, :b => 2).to include(:c) # fails
  #   expect(:a => 1, :b => 2).not_to include(:a => 2)
  def a_hash_including(*args, &block); end

  # Passes if actual.kind_of?(expected)
  #
  # @example
  #   expect(5).to     be_a_kind_of(Integer)
  #   expect(5).to     be_a_kind_of(Numeric)
  #   expect(5).not_to be_a_kind_of(Float)
  def a_kind_of(*args, &block); end

  # Passes if actual is nil
  def a_nil_value(*args, &block); end

  # Passes if actual covers expected. This works for
  # Ranges. You can also pass in multiple args
  # and it will only pass if all args are found in Range.
  #
  # ### Warning:: Ruby >= 1.9 only
  #
  # @example
  #   expect(1..10).to     cover(5)
  #   expect(1..10).to     cover(4, 6)
  #   expect(1..10).to     cover(4, 6, 11) # fails
  #   expect(1..10).not_to cover(11)
  #   expect(1..10).not_to cover(5)        # fails
  def a_range_covering(*args, &block); end

  # Matches if the actual value ends with the expected value(s). In the case
  # of a string, matches against the last `expected.length` characters of the
  # actual string. In the case of an array, matches against the last
  # `expected.length` elements of the actual array.
  #
  # @example
  #   expect("this string").to   end_with "string"
  #   expect([0, 1, 2, 3, 4]).to end_with 4
  #   expect([0, 2, 3, 4, 4]).to end_with 3, 4
  def a_string_ending_with(*args, &block); end

  # Passes if actual includes expected. This works for
  # collections and Strings. You can also pass in multiple args
  # and it will only pass if all args are found in collection.
  #
  # @example
  #   expect([1,2,3]).to      include(3)
  #   expect([1,2,3]).to      include(2,3)
  #   expect([1,2,3]).to      include(2,3,4) # fails
  #   expect([1,2,3]).not_to  include(4)
  #   expect("spread").to     include("read")
  #   expect("spread").not_to include("red")
  #   expect(:a => 1, :b => 2).to include(:a)
  #   expect(:a => 1, :b => 2).to include(:a, :b)
  #   expect(:a => 1, :b => 2).to include(:a => 1)
  #   expect(:a => 1, :b => 2).to include(:b => 2, :a => 1)
  #   expect(:a => 1, :b => 2).to include(:c) # fails
  #   expect(:a => 1, :b => 2).not_to include(:a => 2)
  def a_string_including(*args, &block); end

  # Given a `Regexp` or `String`, passes if `actual.match(pattern)`
  # Given an arbitrary nested data structure (e.g. arrays and hashes),
  # matches if `expected === actual` || `actual == expected` for each
  # pair of elements.
  #
  # @example
  #   expect(email).to match(/^([^\s]+)((?:[-a-z0-9]+\.)+[a-z]{2,})$/i)
  #   expect(email).to match("@example.com")
  # @example
  #   hash = {
  #   :a => {
  #   :b => ["foo", 5],
  #   :c => { :d => 2.05 }
  #   }
  #   }
  #
  #   expect(hash).to match(
  #   :a => {
  #   :b => a_collection_containing_exactly(
  #   a_string_starting_with("f"),
  #   an_instance_of(Integer)
  #   ),
  #   :c => { :d => (a_value < 3) }
  #   }
  #   )
  # @note The `match_regex` alias is deprecated and is not recommended for use.
  #   It was added in 2.12.1 to facilitate its use from within custom
  #   matchers (due to how the custom matcher DSL was evaluated in 2.x,
  #   `match` could not be used there), but is no longer needed in 3.x.
  def a_string_matching(*args, &block); end

  # Matches if the actual value starts with the expected value(s). In the
  # case of a string, matches against the first `expected.length` characters
  # of the actual string. In the case of an array, matches against the first
  # `expected.length` elements of the actual array.
  #
  # @example
  #   expect("this string").to   start_with "this s"
  #   expect([0, 1, 2, 3, 4]).to start_with 0
  #   expect([0, 2, 3, 4, 4]).to start_with 0, 1
  def a_string_starting_with(*args, &block); end

  # Passes if actual is truthy (anything but false or nil)
  def a_truthy_value(*args, &block); end

  # Given true, false, or nil, will pass if actual value is true, false or
  # nil (respectively). Given no args means the caller should satisfy an if
  # condition (to be or not to be).
  #
  # Predicates are any Ruby method that ends in a "?" and returns true or
  # false.  Given be_ followed by arbitrary_predicate (without the "?"),
  # RSpec will match convert that into a query against the target object.
  #
  # The arbitrary_predicate feature will handle any predicate prefixed with
  # "be_an_" (e.g. be_an_instance_of), "be_a_" (e.g. be_a_kind_of) or "be_"
  # (e.g. be_empty), letting you choose the prefix that best suits the
  # predicate.
  #
  # @example
  #   expect(actual).to     be_truthy
  #   expect(actual).to     be_falsey
  #   expect(actual).to     be_nil
  #   expect(actual).to     be_[arbitrary_predicate](*args)
  #   expect(actual).not_to be_nil
  #   expect(actual).not_to be_[arbitrary_predicate](*args)
  def a_value(*args, &block); end

  # Passes if actual.between?(min, max). Works with any Comparable object,
  # including String, Symbol, Time, or Numeric (Fixnum, Bignum, Integer,
  # Float, Complex, and Rational).
  #
  # By default, `be_between` is inclusive (i.e. passes when given either the max or min value),
  # but you can make it `exclusive` by chaining that off the matcher.
  #
  # @example
  #   expect(5).to      be_between(1, 10)
  #   expect(11).not_to be_between(1, 10)
  #   expect(10).not_to be_between(1, 10).exclusive
  def a_value_between(*args, &block); end

  # Passes if actual == expected +/- delta
  #
  # @example
  #   expect(result).to     be_within(0.5).of(3.0)
  #   expect(result).not_to be_within(0.5).of(3.0)
  def a_value_within(*args, &block); end

  # Allows multiple expectations in the provided block to fail, and then
  # aggregates them into a single exception, rather than aborting on the
  # first expectation failure like normal. This allows you to see all
  # failures from an entire set of expectations without splitting each
  # off into its own example (which may slow things down if the example
  # setup is expensive).
  #
  # @example
  #   aggregate_failures("verifying response") do
  #   expect(response.status).to eq(200)
  #   expect(response.headers).to include("Content-Type" => "text/plain")
  #   expect(response.body).to include("Success")
  #   end
  # @note The implementation of this feature uses a thread-local variable,
  #   which means that if you have an expectation failure in another thread,
  #   it'll abort like normal.
  # @param label [String] label for this aggregation block, which will be
  #   included in the aggregated exception message.
  # @param metadata [Hash] additional metadata about this failure aggregation
  #   block. If multiple expectations fail, it will be exposed from the
  #   {Expectations::MultipleExpectationsNotMetError} exception. Mostly
  #   intended for internal RSpec use but you can use it as well.
  # @raise [Expectations::MultipleExpectationsNotMetError] raised when
  #   multiple expectations fail.
  # @raise [Expectations::ExpectationNotMetError] raised when a single
  #   expectation fails.
  # @raise [Exception] other sorts of exceptions will be raised as normal.
  # @yield Block containing as many expectation as you want. The block is
  #   simply yielded to, so you can trust that anything that works outside
  #   the block should work within it.
  def aggregate_failures(label = T.unsafe(nil), metadata = T.unsafe(nil), &block); end

  # Passes if the provided matcher passes when checked against all
  # elements of the collection.
  #
  # @example
  #   expect([1, 3, 5]).to all be_odd
  #   expect([1, 3, 6]).to all be_odd # fails
  # @example
  #   expect([1, 3, 5]).to all( be_odd.and be_an(Integer) )
  # @note The negative form `not_to all` is not supported. Instead
  #   use `not_to include` or pass a negative form of a matcher
  #   as the argument (e.g. `all exclude(:foo)`).
  # @note You can also use this with compound matchers as well.
  def all(expected); end

  # Passes if actual.instance_of?(expected)
  #
  # @example
  #   expect(5).to     be_an_instance_of(Integer)
  #   expect(5).not_to be_an_instance_of(Numeric)
  #   expect(5).not_to be_an_instance_of(Float)
  def an_instance_of(*args, &block); end

  # Passes if <tt>actual == expected</tt>.
  #
  # See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more
  # information about equality in Ruby.
  #
  # @example
  #   expect(5).to     eq(5)
  #   expect(5).not_to eq(3)
  def an_object_eq_to(*args, &block); end

  # Passes if `actual.eql?(expected)`
  #
  # See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more
  # information about equality in Ruby.
  #
  # @example
  #   expect(5).to     eql(5)
  #   expect(5).not_to eql(3)
  def an_object_eql_to(*args, &block); end

  # Passes if <tt>actual.equal?(expected)</tt> (object identity).
  #
  # See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more
  # information about equality in Ruby.
  #
  # @example
  #   expect(5).to       equal(5)   # Integers are equal
  #   expect("5").not_to equal("5") # Strings that look the same are not the same object
  def an_object_equal_to(*args, &block); end

  # Passes if `actual.exist?` or `actual.exists?`
  #
  # @example
  #   expect(File).to exist("path/to/file")
  def an_object_existing(*args, &block); end

  # Passes if actual's attribute values match the expected attributes hash.
  # This works no matter how you define your attribute readers.
  #
  # @example
  #   Person = Struct.new(:name, :age)
  #   person = Person.new("Bob", 32)
  #
  #   expect(person).to have_attributes(:name => "Bob", :age => 32)
  #   expect(person).to have_attributes(:name => a_string_starting_with("B"), :age => (a_value > 30) )
  # @example
  #   expect(person).to have_attributes(:color => "red")
  # @note It will fail if actual doesn't respond to any of the expected attributes.
  def an_object_having_attributes(*args, &block); end

  # Given a `Regexp` or `String`, passes if `actual.match(pattern)`
  # Given an arbitrary nested data structure (e.g. arrays and hashes),
  # matches if `expected === actual` || `actual == expected` for each
  # pair of elements.
  #
  # @example
  #   expect(email).to match(/^([^\s]+)((?:[-a-z0-9]+\.)+[a-z]{2,})$/i)
  #   expect(email).to match("@example.com")
  # @example
  #   hash = {
  #   :a => {
  #   :b => ["foo", 5],
  #   :c => { :d => 2.05 }
  #   }
  #   }
  #
  #   expect(hash).to match(
  #   :a => {
  #   :b => a_collection_containing_exactly(
  #   a_string_starting_with("f"),
  #   an_instance_of(Integer)
  #   ),
  #   :c => { :d => (a_value < 3) }
  #   }
  #   )
  # @note The `match_regex` alias is deprecated and is not recommended for use.
  #   It was added in 2.12.1 to facilitate its use from within custom
  #   matchers (due to how the custom matcher DSL was evaluated in 2.x,
  #   `match` could not be used there), but is no longer needed in 3.x.
  def an_object_matching(*args, &block); end

  # Matches if the target object responds to all of the names
  # provided. Names can be Strings or Symbols.
  #
  # @example
  #   expect("string").to respond_to(:length)
  def an_object_responding_to(*args, &block); end

  # Passes if the submitted block returns true. Yields target to the
  # block.
  #
  # Generally speaking, this should be thought of as a last resort when
  # you can't find any other way to specify the behaviour you wish to
  # specify.
  #
  # If you do find yourself in such a situation, you could always write
  # a custom matcher, which would likely make your specs more expressive.
  #
  # @example
  #   expect(5).to satisfy { |n| n > 3 }
  #   expect(5).to satisfy("be greater than 3") { |n| n > 3 }
  # @param description [String] optional description to be used for this matcher.
  def an_object_satisfying(*args, &block); end

  # Given true, false, or nil, will pass if actual value is true, false or
  # nil (respectively). Given no args means the caller should satisfy an if
  # condition (to be or not to be).
  #
  # Predicates are any Ruby method that ends in a "?" and returns true or
  # false.  Given be_ followed by arbitrary_predicate (without the "?"),
  # RSpec will match convert that into a query against the target object.
  #
  # The arbitrary_predicate feature will handle any predicate prefixed with
  # "be_an_" (e.g. be_an_instance_of), "be_a_" (e.g. be_a_kind_of) or "be_"
  # (e.g. be_empty), letting you choose the prefix that best suits the
  # predicate.
  #
  # @example
  #   expect(actual).to     be_truthy
  #   expect(actual).to     be_falsey
  #   expect(actual).to     be_nil
  #   expect(actual).to     be_[arbitrary_predicate](*args)
  #   expect(actual).not_to be_nil
  #   expect(actual).not_to be_[arbitrary_predicate](*args)
  def be(*args); end

  # passes if target.kind_of?(klass)
  def be_a(klass); end

  # Passes if actual.kind_of?(expected)
  #
  # @example
  #   expect(5).to     be_a_kind_of(Integer)
  #   expect(5).to     be_a_kind_of(Numeric)
  #   expect(5).not_to be_a_kind_of(Float)
  def be_a_kind_of(expected); end

  # passes if target.kind_of?(klass)
  def be_an(klass); end

  # Passes if actual.instance_of?(expected)
  #
  # @example
  #   expect(5).to     be_an_instance_of(Integer)
  #   expect(5).not_to be_an_instance_of(Numeric)
  #   expect(5).not_to be_an_instance_of(Float)
  def be_an_instance_of(expected); end

  # Passes if actual.between?(min, max). Works with any Comparable object,
  # including String, Symbol, Time, or Numeric (Fixnum, Bignum, Integer,
  # Float, Complex, and Rational).
  #
  # By default, `be_between` is inclusive (i.e. passes when given either the max or min value),
  # but you can make it `exclusive` by chaining that off the matcher.
  #
  # @example
  #   expect(5).to      be_between(1, 10)
  #   expect(11).not_to be_between(1, 10)
  #   expect(10).not_to be_between(1, 10).exclusive
  def be_between(min, max); end

  # Passes if actual is falsey (false or nil)
  def be_falsey; end

  # Passes if actual is falsey (false or nil)
  def be_falsy(*args, &block); end

  # Passes if actual.instance_of?(expected)
  #
  # @example
  #   expect(5).to     be_an_instance_of(Integer)
  #   expect(5).not_to be_an_instance_of(Numeric)
  #   expect(5).not_to be_an_instance_of(Float)
  def be_instance_of(expected); end

  # Passes if actual.kind_of?(expected)
  #
  # @example
  #   expect(5).to     be_a_kind_of(Integer)
  #   expect(5).to     be_a_kind_of(Numeric)
  #   expect(5).not_to be_a_kind_of(Float)
  def be_kind_of(expected); end

  # Passes if actual is nil
  def be_nil; end

  # Passes if actual is truthy (anything but false or nil)
  def be_truthy; end

  # Passes if actual == expected +/- delta
  #
  # @example
  #   expect(result).to     be_within(0.5).of(3.0)
  #   expect(result).not_to be_within(0.5).of(3.0)
  def be_within(delta); end

  # Applied to a proc, specifies that its execution will cause some value to
  # change.
  #
  # You can either pass <tt>receiver</tt> and <tt>message</tt>, or a block,
  # but not both.
  #
  # When passing a block, it must use the `{ ... }` format, not
  # do/end, as `{ ... }` binds to the `change` method, whereas do/end
  # would errantly bind to the `expect(..).to` or `expect(...).not_to` method.
  #
  # You can chain any of the following off of the end to specify details
  # about the change:
  #
  # * `from`
  # * `to`
  #
  # or any one of:
  #
  # * `by`
  # * `by_at_least`
  # * `by_at_most`
  #
  # == Notes
  #
  # Evaluates `receiver.message` or `block` before and after it
  # evaluates the block passed to `expect`. If the value is the same
  # object, its before/after `hash` value is used to see if it has changed.
  # Therefore, your object needs to properly implement `hash` to work correctly
  # with this matcher.
  #
  # `expect( ... ).not_to change` supports the form that specifies `from`
  # (which specifies what you expect the starting, unchanged value to be)
  # but does not support forms with subsequent calls to `by`, `by_at_least`,
  # `by_at_most` or `to`.
  #
  # @example
  #   expect {
  #   team.add_player(player)
  #   }.to change(roster, :count)
  #
  #   expect {
  #   team.add_player(player)
  #   }.to change(roster, :count).by(1)
  #
  #   expect {
  #   team.add_player(player)
  #   }.to change(roster, :count).by_at_least(1)
  #
  #   expect {
  #   team.add_player(player)
  #   }.to change(roster, :count).by_at_most(1)
  #
  #   string = "string"
  #   expect {
  #   string.reverse!
  #   }.to change { string }.from("string").to("gnirts")
  #
  #   string = "string"
  #   expect {
  #   string
  #   }.not_to change { string }.from("string")
  #
  #   expect {
  #   person.happy_birthday
  #   }.to change(person, :birthday).from(32).to(33)
  #
  #   expect {
  #   employee.develop_great_new_social_networking_app
  #   }.to change(employee, :title).from("Mail Clerk").to("CEO")
  #
  #   expect {
  #   doctor.leave_office
  #   }.to change(doctor, :sign).from(/is in/).to(/is out/)
  #
  #   user = User.new(:type => "admin")
  #   expect {
  #   user.symbolize_type
  #   }.to change(user, :type).from(String).to(Symbol)
  # @param receiver [Object]
  # @param message [Symbol] the message to send the receiver
  def change(receiver = T.unsafe(nil), message = T.unsafe(nil), &block); end

  # Applied to a proc, specifies that its execution will cause some value to
  # change.
  #
  # You can either pass <tt>receiver</tt> and <tt>message</tt>, or a block,
  # but not both.
  #
  # When passing a block, it must use the `{ ... }` format, not
  # do/end, as `{ ... }` binds to the `change` method, whereas do/end
  # would errantly bind to the `expect(..).to` or `expect(...).not_to` method.
  #
  # You can chain any of the following off of the end to specify details
  # about the change:
  #
  # * `from`
  # * `to`
  #
  # or any one of:
  #
  # * `by`
  # * `by_at_least`
  # * `by_at_most`
  #
  # == Notes
  #
  # Evaluates `receiver.message` or `block` before and after it
  # evaluates the block passed to `expect`. If the value is the same
  # object, its before/after `hash` value is used to see if it has changed.
  # Therefore, your object needs to properly implement `hash` to work correctly
  # with this matcher.
  #
  # `expect( ... ).not_to change` supports the form that specifies `from`
  # (which specifies what you expect the starting, unchanged value to be)
  # but does not support forms with subsequent calls to `by`, `by_at_least`,
  # `by_at_most` or `to`.
  #
  # @example
  #   expect {
  #   team.add_player(player)
  #   }.to change(roster, :count)
  #
  #   expect {
  #   team.add_player(player)
  #   }.to change(roster, :count).by(1)
  #
  #   expect {
  #   team.add_player(player)
  #   }.to change(roster, :count).by_at_least(1)
  #
  #   expect {
  #   team.add_player(player)
  #   }.to change(roster, :count).by_at_most(1)
  #
  #   string = "string"
  #   expect {
  #   string.reverse!
  #   }.to change { string }.from("string").to("gnirts")
  #
  #   string = "string"
  #   expect {
  #   string
  #   }.not_to change { string }.from("string")
  #
  #   expect {
  #   person.happy_birthday
  #   }.to change(person, :birthday).from(32).to(33)
  #
  #   expect {
  #   employee.develop_great_new_social_networking_app
  #   }.to change(employee, :title).from("Mail Clerk").to("CEO")
  #
  #   expect {
  #   doctor.leave_office
  #   }.to change(doctor, :sign).from(/is in/).to(/is out/)
  #
  #   user = User.new(:type => "admin")
  #   expect {
  #   user.symbolize_type
  #   }.to change(user, :type).from(String).to(Symbol)
  # @param receiver [Object]
  # @param message [Symbol] the message to send the receiver
  def changing(*args, &block); end

  # Passes if actual contains all of the expected regardless of order.
  # This works for collections. Pass in multiple args and it will only
  # pass if all args are found in collection.
  #
  # @example
  #   expect([1, 2, 3]).to contain_exactly(1, 2, 3)
  #   expect([1, 2, 3]).to contain_exactly(1, 3, 2)
  # @note This is also available using the `=~` operator with `should`,
  #   but `=~` is not supported with `expect`.
  # @see #match_array
  def contain_exactly(*items); end

  # Passes if actual contains all of the expected regardless of order.
  # This works for collections. Pass in multiple args and it will only
  # pass if all args are found in collection.
  #
  # @example
  #   expect([1, 2, 3]).to contain_exactly(1, 2, 3)
  #   expect([1, 2, 3]).to contain_exactly(1, 3, 2)
  # @note This is also available using the `=~` operator with `should`,
  #   but `=~` is not supported with `expect`.
  # @see #match_array
  def containing_exactly(*args, &block); end

  # Passes if actual covers expected. This works for
  # Ranges. You can also pass in multiple args
  # and it will only pass if all args are found in Range.
  #
  # ### Warning:: Ruby >= 1.9 only
  #
  # @example
  #   expect(1..10).to     cover(5)
  #   expect(1..10).to     cover(4, 6)
  #   expect(1..10).to     cover(4, 6, 11) # fails
  #   expect(1..10).not_to cover(11)
  #   expect(1..10).not_to cover(5)        # fails
  def cover(*values); end

  # Passes if actual covers expected. This works for
  # Ranges. You can also pass in multiple args
  # and it will only pass if all args are found in Range.
  #
  # ### Warning:: Ruby >= 1.9 only
  #
  # @example
  #   expect(1..10).to     cover(5)
  #   expect(1..10).to     cover(4, 6)
  #   expect(1..10).to     cover(4, 6, 11) # fails
  #   expect(1..10).not_to cover(11)
  #   expect(1..10).not_to cover(5)        # fails
  def covering(*args, &block); end

  # Matches if the actual value ends with the expected value(s). In the case
  # of a string, matches against the last `expected.length` characters of the
  # actual string. In the case of an array, matches against the last
  # `expected.length` elements of the actual array.
  #
  # @example
  #   expect("this string").to   end_with "string"
  #   expect([0, 1, 2, 3, 4]).to end_with 4
  #   expect([0, 2, 3, 4, 4]).to end_with 3, 4
  def end_with(*expected); end

  # Matches if the actual value ends with the expected value(s). In the case
  # of a string, matches against the last `expected.length` characters of the
  # actual string. In the case of an array, matches against the last
  # `expected.length` elements of the actual array.
  #
  # @example
  #   expect("this string").to   end_with "string"
  #   expect([0, 1, 2, 3, 4]).to end_with 4
  #   expect([0, 2, 3, 4, 4]).to end_with 3, 4
  def ending_with(*args, &block); end

  # Passes if <tt>actual == expected</tt>.
  #
  # See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more
  # information about equality in Ruby.
  #
  # @example
  #   expect(5).to     eq(5)
  #   expect(5).not_to eq(3)
  def eq(expected); end

  # Passes if <tt>actual == expected</tt>.
  #
  # See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more
  # information about equality in Ruby.
  #
  # @example
  #   expect(5).to     eq(5)
  #   expect(5).not_to eq(3)
  def eq_to(*args, &block); end

  # Passes if `actual.eql?(expected)`
  #
  # See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more
  # information about equality in Ruby.
  #
  # @example
  #   expect(5).to     eql(5)
  #   expect(5).not_to eql(3)
  def eql(expected); end

  # Passes if `actual.eql?(expected)`
  #
  # See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more
  # information about equality in Ruby.
  #
  # @example
  #   expect(5).to     eql(5)
  #   expect(5).not_to eql(3)
  def eql_to(*args, &block); end

  # Passes if <tt>actual.equal?(expected)</tt> (object identity).
  #
  # See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more
  # information about equality in Ruby.
  #
  # @example
  #   expect(5).to       equal(5)   # Integers are equal
  #   expect("5").not_to equal("5") # Strings that look the same are not the same object
  def equal(expected); end

  # Passes if <tt>actual.equal?(expected)</tt> (object identity).
  #
  # See http://www.ruby-doc.org/core/classes/Object.html#M001057 for more
  # information about equality in Ruby.
  #
  # @example
  #   expect(5).to       equal(5)   # Integers are equal
  #   expect("5").not_to equal("5") # Strings that look the same are not the same object
  def equal_to(*args, &block); end

  # Passes if `actual.exist?` or `actual.exists?`
  #
  # @example
  #   expect(File).to exist("path/to/file")
  def exist(*args); end

  # Passes if `actual.exist?` or `actual.exists?`
  #
  # @example
  #   expect(File).to exist("path/to/file")
  def existing(*args, &block); end

  # Supports `expect(actual).to matcher` syntax by wrapping `actual` in an
  # `ExpectationTarget`.
  #
  # @example
  #   expect(actual).to eq(expected)
  #   expect(actual).not_to eq(expected)
  # @return [Expectations::ExpectationTarget]
  # @see Expectations::ExpectationTarget#to
  # @see Expectations::ExpectationTarget#not_to
  def expect(value = T.unsafe(nil), &block); end

  # Passes if actual's attribute values match the expected attributes hash.
  # This works no matter how you define your attribute readers.
  #
  # @example
  #   Person = Struct.new(:name, :age)
  #   person = Person.new("Bob", 32)
  #
  #   expect(person).to have_attributes(:name => "Bob", :age => 32)
  #   expect(person).to have_attributes(:name => a_string_starting_with("B"), :age => (a_value > 30) )
  # @example
  #   expect(person).to have_attributes(:color => "red")
  # @note It will fail if actual doesn't respond to any of the expected attributes.
  def have_attributes(expected); end

  # Passes if actual's attribute values match the expected attributes hash.
  # This works no matter how you define your attribute readers.
  #
  # @example
  #   Person = Struct.new(:name, :age)
  #   person = Person.new("Bob", 32)
  #
  #   expect(person).to have_attributes(:name => "Bob", :age => 32)
  #   expect(person).to have_attributes(:name => a_string_starting_with("B"), :age => (a_value > 30) )
  # @example
  #   expect(person).to have_attributes(:color => "red")
  # @note It will fail if actual doesn't respond to any of the expected attributes.
  def having_attributes(*args, &block); end

  # Passes if actual includes expected. This works for
  # collections and Strings. You can also pass in multiple args
  # and it will only pass if all args are found in collection.
  #
  # @example
  #   expect([1,2,3]).to      include(3)
  #   expect([1,2,3]).to      include(2,3)
  #   expect([1,2,3]).to      include(2,3,4) # fails
  #   expect([1,2,3]).not_to  include(4)
  #   expect("spread").to     include("read")
  #   expect("spread").not_to include("red")
  #   expect(:a => 1, :b => 2).to include(:a)
  #   expect(:a => 1, :b => 2).to include(:a, :b)
  #   expect(:a => 1, :b => 2).to include(:a => 1)
  #   expect(:a => 1, :b => 2).to include(:b => 2, :a => 1)
  #   expect(:a => 1, :b => 2).to include(:c) # fails
  #   expect(:a => 1, :b => 2).not_to include(:a => 2)
  def include(*expected); end

  # Passes if actual includes expected. This works for
  # collections and Strings. You can also pass in multiple args
  # and it will only pass if all args are found in collection.
  #
  # @example
  #   expect([1,2,3]).to      include(3)
  #   expect([1,2,3]).to      include(2,3)
  #   expect([1,2,3]).to      include(2,3,4) # fails
  #   expect([1,2,3]).not_to  include(4)
  #   expect("spread").to     include("read")
  #   expect("spread").not_to include("red")
  #   expect(:a => 1, :b => 2).to include(:a)
  #   expect(:a => 1, :b => 2).to include(:a, :b)
  #   expect(:a => 1, :b => 2).to include(:a => 1)
  #   expect(:a => 1, :b => 2).to include(:b => 2, :a => 1)
  #   expect(:a => 1, :b => 2).to include(:c) # fails
  #   expect(:a => 1, :b => 2).not_to include(:a => 2)
  def including(*args, &block); end

  # Given a `Regexp` or `String`, passes if `actual.match(pattern)`
  # Given an arbitrary nested data structure (e.g. arrays and hashes),
  # matches if `expected === actual` || `actual == expected` for each
  # pair of elements.
  #
  # @example
  #   expect(email).to match(/^([^\s]+)((?:[-a-z0-9]+\.)+[a-z]{2,})$/i)
  #   expect(email).to match("@example.com")
  # @example
  #   hash = {
  #   :a => {
  #   :b => ["foo", 5],
  #   :c => { :d => 2.05 }
  #   }
  #   }
  #
  #   expect(hash).to match(
  #   :a => {
  #   :b => a_collection_containing_exactly(
  #   a_string_starting_with("f"),
  #   an_instance_of(Integer)
  #   ),
  #   :c => { :d => (a_value < 3) }
  #   }
  #   )
  # @note The `match_regex` alias is deprecated and is not recommended for use.
  #   It was added in 2.12.1 to facilitate its use from within custom
  #   matchers (due to how the custom matcher DSL was evaluated in 2.x,
  #   `match` could not be used there), but is no longer needed in 3.x.
  def match(expected); end

  # An alternate form of `contain_exactly` that accepts
  # the expected contents as a single array arg rather
  # that splatted out as individual items.
  #
  # @example
  #   expect(results).to contain_exactly(1, 2)
  #   # is identical to:
  #   expect(results).to match_array([1, 2])
  # @see #contain_exactly
  def match_array(items); end

  # Given a `Regexp` or `String`, passes if `actual.match(pattern)`
  # Given an arbitrary nested data structure (e.g. arrays and hashes),
  # matches if `expected === actual` || `actual == expected` for each
  # pair of elements.
  #
  # @example
  #   expect(email).to match(/^([^\s]+)((?:[-a-z0-9]+\.)+[a-z]{2,})$/i)
  #   expect(email).to match("@example.com")
  # @example
  #   hash = {
  #   :a => {
  #   :b => ["foo", 5],
  #   :c => { :d => 2.05 }
  #   }
  #   }
  #
  #   expect(hash).to match(
  #   :a => {
  #   :b => a_collection_containing_exactly(
  #   a_string_starting_with("f"),
  #   an_instance_of(Integer)
  #   ),
  #   :c => { :d => (a_value < 3) }
  #   }
  #   )
  # @note The `match_regex` alias is deprecated and is not recommended for use.
  #   It was added in 2.12.1 to facilitate its use from within custom
  #   matchers (due to how the custom matcher DSL was evaluated in 2.x,
  #   `match` could not be used there), but is no longer needed in 3.x.
  def match_regex(*args, &block); end

  # Given a `Regexp` or `String`, passes if `actual.match(pattern)`
  # Given an arbitrary nested data structure (e.g. arrays and hashes),
  # matches if `expected === actual` || `actual == expected` for each
  # pair of elements.
  #
  # @example
  #   expect(email).to match(/^([^\s]+)((?:[-a-z0-9]+\.)+[a-z]{2,})$/i)
  #   expect(email).to match("@example.com")
  # @example
  #   hash = {
  #   :a => {
  #   :b => ["foo", 5],
  #   :c => { :d => 2.05 }
  #   }
  #   }
  #
  #   expect(hash).to match(
  #   :a => {
  #   :b => a_collection_containing_exactly(
  #   a_string_starting_with("f"),
  #   an_instance_of(Integer)
  #   ),
  #   :c => { :d => (a_value < 3) }
  #   }
  #   )
  # @note The `match_regex` alias is deprecated and is not recommended for use.
  #   It was added in 2.12.1 to facilitate its use from within custom
  #   matchers (due to how the custom matcher DSL was evaluated in 2.x,
  #   `match` could not be used there), but is no longer needed in 3.x.
  def matching(*args, &block); end

  # With no arg, passes if the block outputs `to_stdout` or `to_stderr`.
  # With a string, passes if the block outputs that specific string `to_stdout` or `to_stderr`.
  # With a regexp or matcher, passes if the block outputs a string `to_stdout` or `to_stderr` that matches.
  #
  # To capture output from any spawned subprocess as well, use `to_stdout_from_any_process` or
  # `to_stderr_from_any_process`. Output from any process that inherits the main process's corresponding
  # standard stream will be captured.
  #
  # @example
  #   expect { print 'foo' }.to output.to_stdout
  #   expect { print 'foo' }.to output('foo').to_stdout
  #   expect { print 'foo' }.to output(/foo/).to_stdout
  #
  #   expect { do_something }.to_not output.to_stdout
  #
  #   expect { warn('foo') }.to output.to_stderr
  #   expect { warn('foo') }.to output('foo').to_stderr
  #   expect { warn('foo') }.to output(/foo/).to_stderr
  #
  #   expect { do_something }.to_not output.to_stderr
  #
  #   expect { system('echo foo') }.to output("foo\n").to_stdout_from_any_process
  #   expect { system('echo foo', out: :err) }.to output("foo\n").to_stderr_from_any_process
  # @note `to_stdout` and `to_stderr` work by temporarily replacing `$stdout` or `$stderr`,
  #   so they're not able to intercept stream output that explicitly uses `STDOUT`/`STDERR`
  #   or that uses a reference to `$stdout`/`$stderr` that was stored before the
  #   matcher was used.
  # @note `to_stdout_from_any_process` and `to_stderr_from_any_process` use Tempfiles, and
  #   are thus significantly (~30x) slower than `to_stdout` and `to_stderr`.
  def output(expected = T.unsafe(nil)); end

  # With no args, matches if any error is raised.
  # With a named error, matches only if that specific error is raised.
  # With a named error and messsage specified as a String, matches only if both match.
  # With a named error and messsage specified as a Regexp, matches only if both match.
  # Pass an optional block to perform extra verifications on the exception matched
  #
  # @example
  #   expect { do_something_risky }.to raise_error
  #   expect { do_something_risky }.to raise_error(PoorRiskDecisionError)
  #   expect { do_something_risky }.to raise_error(PoorRiskDecisionError) { |error| expect(error.data).to eq 42 }
  #   expect { do_something_risky }.to raise_error { |error| expect(error.data).to eq 42 }
  #   expect { do_something_risky }.to raise_error(PoorRiskDecisionError, "that was too risky")
  #   expect { do_something_risky }.to raise_error(PoorRiskDecisionError, /oo ri/)
  #   expect { do_something_risky }.to raise_error("that was too risky")
  #
  #   expect { do_something_risky }.not_to raise_error
  def raise_error(error = T.unsafe(nil), message = T.unsafe(nil), &block); end

  # With no args, matches if any error is raised.
  # With a named error, matches only if that specific error is raised.
  # With a named error and messsage specified as a String, matches only if both match.
  # With a named error and messsage specified as a Regexp, matches only if both match.
  # Pass an optional block to perform extra verifications on the exception matched
  #
  # @example
  #   expect { do_something_risky }.to raise_error
  #   expect { do_something_risky }.to raise_error(PoorRiskDecisionError)
  #   expect { do_something_risky }.to raise_error(PoorRiskDecisionError) { |error| expect(error.data).to eq 42 }
  #   expect { do_something_risky }.to raise_error { |error| expect(error.data).to eq 42 }
  #   expect { do_something_risky }.to raise_error(PoorRiskDecisionError, "that was too risky")
  #   expect { do_something_risky }.to raise_error(PoorRiskDecisionError, /oo ri/)
  #   expect { do_something_risky }.to raise_error("that was too risky")
  #
  #   expect { do_something_risky }.not_to raise_error
  def raise_exception(error = T.unsafe(nil), message = T.unsafe(nil), &block); end

  # With no args, matches if any error is raised.
  # With a named error, matches only if that specific error is raised.
  # With a named error and messsage specified as a String, matches only if both match.
  # With a named error and messsage specified as a Regexp, matches only if both match.
  # Pass an optional block to perform extra verifications on the exception matched
  #
  # @example
  #   expect { do_something_risky }.to raise_error
  #   expect { do_something_risky }.to raise_error(PoorRiskDecisionError)
  #   expect { do_something_risky }.to raise_error(PoorRiskDecisionError) { |error| expect(error.data).to eq 42 }
  #   expect { do_something_risky }.to raise_error { |error| expect(error.data).to eq 42 }
  #   expect { do_something_risky }.to raise_error(PoorRiskDecisionError, "that was too risky")
  #   expect { do_something_risky }.to raise_error(PoorRiskDecisionError, /oo ri/)
  #   expect { do_something_risky }.to raise_error("that was too risky")
  #
  #   expect { do_something_risky }.not_to raise_error
  def raising(*args, &block); end

  # Matches if the target object responds to all of the names
  # provided. Names can be Strings or Symbols.
  #
  # @example
  #   expect("string").to respond_to(:length)
  def respond_to(*names); end

  # Matches if the target object responds to all of the names
  # provided. Names can be Strings or Symbols.
  #
  # @example
  #   expect("string").to respond_to(:length)
  def responding_to(*args, &block); end

  # Passes if the submitted block returns true. Yields target to the
  # block.
  #
  # Generally speaking, this should be thought of as a last resort when
  # you can't find any other way to specify the behaviour you wish to
  # specify.
  #
  # If you do find yourself in such a situation, you could always write
  # a custom matcher, which would likely make your specs more expressive.
  #
  # @example
  #   expect(5).to satisfy { |n| n > 3 }
  #   expect(5).to satisfy("be greater than 3") { |n| n > 3 }
  # @param description [String] optional description to be used for this matcher.
  def satisfy(description = T.unsafe(nil), &block); end

  # Passes if the submitted block returns true. Yields target to the
  # block.
  #
  # Generally speaking, this should be thought of as a last resort when
  # you can't find any other way to specify the behaviour you wish to
  # specify.
  #
  # If you do find yourself in such a situation, you could always write
  # a custom matcher, which would likely make your specs more expressive.
  #
  # @example
  #   expect(5).to satisfy { |n| n > 3 }
  #   expect(5).to satisfy("be greater than 3") { |n| n > 3 }
  # @param description [String] optional description to be used for this matcher.
  def satisfying(*args, &block); end

  # Matches if the actual value starts with the expected value(s). In the
  # case of a string, matches against the first `expected.length` characters
  # of the actual string. In the case of an array, matches against the first
  # `expected.length` elements of the actual array.
  #
  # @example
  #   expect("this string").to   start_with "this s"
  #   expect([0, 1, 2, 3, 4]).to start_with 0
  #   expect([0, 2, 3, 4, 4]).to start_with 0, 1
  def start_with(*expected); end

  # Matches if the actual value starts with the expected value(s). In the
  # case of a string, matches against the first `expected.length` characters
  # of the actual string. In the case of an array, matches against the first
  # `expected.length` elements of the actual array.
  #
  # @example
  #   expect("this string").to   start_with "this s"
  #   expect([0, 1, 2, 3, 4]).to start_with 0
  #   expect([0, 2, 3, 4, 4]).to start_with 0, 1
  def starting_with(*args, &block); end

  # Given no argument, matches if a proc throws any Symbol.
  #
  # Given a Symbol, matches if the given proc throws the specified Symbol.
  #
  # Given a Symbol and an arg, matches if the given proc throws the
  # specified Symbol with the specified arg.
  #
  # @example
  #   expect { do_something_risky }.to throw_symbol
  #   expect { do_something_risky }.to throw_symbol(:that_was_risky)
  #   expect { do_something_risky }.to throw_symbol(:that_was_risky, 'culprit')
  #
  #   expect { do_something_risky }.not_to throw_symbol
  #   expect { do_something_risky }.not_to throw_symbol(:that_was_risky)
  #   expect { do_something_risky }.not_to throw_symbol(:that_was_risky, 'culprit')
  def throw_symbol(expected_symbol = T.unsafe(nil), expected_arg = T.unsafe(nil)); end

  # Given no argument, matches if a proc throws any Symbol.
  #
  # Given a Symbol, matches if the given proc throws the specified Symbol.
  #
  # Given a Symbol and an arg, matches if the given proc throws the
  # specified Symbol with the specified arg.
  #
  # @example
  #   expect { do_something_risky }.to throw_symbol
  #   expect { do_something_risky }.to throw_symbol(:that_was_risky)
  #   expect { do_something_risky }.to throw_symbol(:that_was_risky, 'culprit')
  #
  #   expect { do_something_risky }.not_to throw_symbol
  #   expect { do_something_risky }.not_to throw_symbol(:that_was_risky)
  #   expect { do_something_risky }.not_to throw_symbol(:that_was_risky, 'culprit')
  def throwing(*args, &block); end

  # Passes if actual == expected +/- delta
  #
  # @example
  #   expect(result).to     be_within(0.5).of(3.0)
  #   expect(result).not_to be_within(0.5).of(3.0)
  def within(*args, &block); end

  # Passes if the method called in the expect block yields, regardless
  # of whether or not arguments are yielded.
  #
  # @example
  #   expect { |b| 5.tap(&b) }.to yield_control
  #   expect { |b| "a".to_sym(&b) }.not_to yield_control
  # @note Your expect block must accept a parameter and pass it on to
  #   the method-under-test as a block.
  def yield_control; end

  # Designed for use with methods that repeatedly yield (such as
  # iterators). Passes if the method called in the expect block yields
  # multiple times with arguments matching those given.
  #
  # Argument matching is done using `===` (the case match operator)
  # and `==`. If the expected and actual arguments match with either
  # operator, the matcher will pass.
  #
  # @example
  #   expect { |b| [1, 2, 3].each(&b) }.to yield_successive_args(1, 2, 3)
  #   expect { |b| { :a => 1, :b => 2 }.each(&b) }.to yield_successive_args([:a, 1], [:b, 2])
  #   expect { |b| [1, 2, 3].each(&b) }.not_to yield_successive_args(1, 2)
  # @note Your expect block must accept a parameter and pass it on to
  #   the method-under-test as a block.
  def yield_successive_args(*args); end

  # Given no arguments, matches if the method called in the expect
  # block yields with arguments (regardless of what they are or how
  # many there are).
  #
  # Given arguments, matches if the method called in the expect block
  # yields with arguments that match the given arguments.
  #
  # Argument matching is done using `===` (the case match operator)
  # and `==`. If the expected and actual arguments match with either
  # operator, the matcher will pass.
  #
  # @example
  #   expect { |b| 5.tap(&b) }.to yield_with_args # because #tap yields an arg
  #   expect { |b| 5.tap(&b) }.to yield_with_args(5) # because 5 == 5
  #   expect { |b| 5.tap(&b) }.to yield_with_args(Integer) # because Integer === 5
  #   expect { |b| File.open("f.txt", &b) }.to yield_with_args(/txt/) # because /txt/ === "f.txt"
  #
  #   expect { |b| User.transaction(&b) }.not_to yield_with_args # because it yields no args
  #   expect { |b| 5.tap(&b) }.not_to yield_with_args(1, 2, 3)
  # @note Your expect block must accept a parameter and pass it on to
  #   the method-under-test as a block.
  # @note This matcher is not designed for use with methods that yield
  #   multiple times.
  def yield_with_args(*args); end

  # Passes if the method called in the expect block yields with
  # no arguments. Fails if it does not yield, or yields with arguments.
  #
  # @example
  #   expect { |b| User.transaction(&b) }.to yield_with_no_args
  #   expect { |b| 5.tap(&b) }.not_to yield_with_no_args # because it yields with `5`
  #   expect { |b| "a".to_sym(&b) }.not_to yield_with_no_args # because it does not yield
  # @note Your expect block must accept a parameter and pass it on to
  #   the method-under-test as a block.
  # @note This matcher is not designed for use with methods that yield
  #   multiple times.
  def yield_with_no_args; end

  # Passes if the method called in the expect block yields, regardless
  # of whether or not arguments are yielded.
  #
  # @example
  #   expect { |b| 5.tap(&b) }.to yield_control
  #   expect { |b| "a".to_sym(&b) }.not_to yield_control
  # @note Your expect block must accept a parameter and pass it on to
  #   the method-under-test as a block.
  def yielding_control(*args, &block); end

  # Designed for use with methods that repeatedly yield (such as
  # iterators). Passes if the method called in the expect block yields
  # multiple times with arguments matching those given.
  #
  # Argument matching is done using `===` (the case match operator)
  # and `==`. If the expected and actual arguments match with either
  # operator, the matcher will pass.
  #
  # @example
  #   expect { |b| [1, 2, 3].each(&b) }.to yield_successive_args(1, 2, 3)
  #   expect { |b| { :a => 1, :b => 2 }.each(&b) }.to yield_successive_args([:a, 1], [:b, 2])
  #   expect { |b| [1, 2, 3].each(&b) }.not_to yield_successive_args(1, 2)
  # @note Your expect block must accept a parameter and pass it on to
  #   the method-under-test as a block.
  def yielding_successive_args(*args, &block); end

  # Given no arguments, matches if the method called in the expect
  # block yields with arguments (regardless of what they are or how
  # many there are).
  #
  # Given arguments, matches if the method called in the expect block
  # yields with arguments that match the given arguments.
  #
  # Argument matching is done using `===` (the case match operator)
  # and `==`. If the expected and actual arguments match with either
  # operator, the matcher will pass.
  #
  # @example
  #   expect { |b| 5.tap(&b) }.to yield_with_args # because #tap yields an arg
  #   expect { |b| 5.tap(&b) }.to yield_with_args(5) # because 5 == 5
  #   expect { |b| 5.tap(&b) }.to yield_with_args(Integer) # because Integer === 5
  #   expect { |b| File.open("f.txt", &b) }.to yield_with_args(/txt/) # because /txt/ === "f.txt"
  #
  #   expect { |b| User.transaction(&b) }.not_to yield_with_args # because it yields no args
  #   expect { |b| 5.tap(&b) }.not_to yield_with_args(1, 2, 3)
  # @note Your expect block must accept a parameter and pass it on to
  #   the method-under-test as a block.
  # @note This matcher is not designed for use with methods that yield
  #   multiple times.
  def yielding_with_args(*args, &block); end

  # Passes if the method called in the expect block yields with
  # no arguments. Fails if it does not yield, or yields with arguments.
  #
  # @example
  #   expect { |b| User.transaction(&b) }.to yield_with_no_args
  #   expect { |b| 5.tap(&b) }.not_to yield_with_no_args # because it yields with `5`
  #   expect { |b| "a".to_sym(&b) }.not_to yield_with_no_args # because it does not yield
  # @note Your expect block must accept a parameter and pass it on to
  #   the method-under-test as a block.
  # @note This matcher is not designed for use with methods that yield
  #   multiple times.
  def yielding_with_no_args(*args, &block); end

  private

  def method_missing(method, *args, **_arg2, &block); end

  # @return [Boolean]
  def respond_to_missing?(method, *_arg1); end

  class << self
    # Extended from {RSpec::Matchers::DSL#alias_matcher}.
    def alias_matcher(*args, &block); end

    # Used by rspec-core to clear the state used to generate
    # descriptions after an example.
    #
    # @api private
    def clear_generated_description; end

    # Delegates to {RSpec::Expectations.configuration}.
    # This is here because rspec-core's `expect_with` option
    # looks for a `configuration` method on the mixin
    # (`RSpec::Matchers`) to yield to a block.
    #
    # @return [RSpec::Expectations::Configuration] the configuration object
    def configuration; end

    # Generates an an example description based on the last expectation.
    # Used by rspec-core's one-liner syntax.
    #
    # @api private
    def generated_description; end

    # @api private
    # @return [Boolean]
    def is_a_describable_matcher?(obj); end

    # @api private
    # @return [Boolean]
    def is_a_matcher?(obj); end

    # @private
    def last_description; end

    # @private
    def last_expectation_handler; end

    # @private
    def last_expectation_handler=(_arg0); end

    # @private
    def last_matcher; end

    # @private
    def last_matcher=(_arg0); end
  end
end

# Decorator that wraps a matcher and overrides `description`
# using the provided block in order to support an alias
# of a matcher. This is intended for use when composing
# matchers, so that you can use an expression like
# `include( a_value_within(0.1).of(3) )` rather than
# `include( be_within(0.1).of(3) )`, and have the corresponding
# description read naturally.
#
# @api private
class RSpec::Matchers::AliasedMatcher < ::RSpec::Matchers::MatcherDelegator
  # @api private
  # @return [AliasedMatcher] a new instance of AliasedMatcher
  def initialize(base_matcher, description_block); end

  # Provides the description of the aliased matcher. Aliased matchers
  # are designed to behave identically to the original matcher except
  # for the description and failure messages. The description is different
  # to reflect the aliased name.
  #
  # @api private
  def description; end

  # Provides the failure_message of the aliased matcher. Aliased matchers
  # are designed to behave identically to the original matcher except
  # for the description and failure messages. The failure_message is different
  # to reflect the aliased name.
  #
  # @api private
  def failure_message; end

  # Provides the failure_message_when_negated of the aliased matcher. Aliased matchers
  # are designed to behave identically to the original matcher except
  # for the description and failure messages. The failure_message_when_negated is different
  # to reflect the aliased name.
  #
  # @api private
  def failure_message_when_negated; end

  # Forward messages on to the wrapped matcher.
  # Since many matchers provide a fluent interface
  # (e.g. `a_value_within(0.1).of(3)`), we need to wrap
  # the returned value if it responds to `description`,
  # so that our override can be applied when it is eventually
  # used.
  #
  # @api private
  def method_missing(*_arg0); end
end

# Decorator used for matchers that have special implementations of
# operators like `==` and `===`.
#
# @private
class RSpec::Matchers::AliasedMatcherWithOperatorSupport < ::RSpec::Matchers::AliasedMatcher; end

# @private
class RSpec::Matchers::AliasedNegatedMatcher < ::RSpec::Matchers::AliasedMatcher
  # @return [Boolean]
  def does_not_match?(*args, &block); end

  def failure_message; end
  def failure_message_when_negated; end

  # @return [Boolean]
  def matches?(*args, &block); end

  private

  # For a matcher that uses the default failure messages, we prefer to
  # use the override provided by the `description_block`, because it
  # includes the phrasing that the user has expressed a preference for
  # by going through the effort of defining a negated matcher.
  #
  # However, if the override didn't actually change anything, then we
  # should return the opposite failure message instead -- the overriden
  # message is going to be confusing if we return it as-is, as it represents
  # the non-negated failure message for a negated match (or vice versa).
  def optimal_failure_message(same, inverted); end
end

RSpec::Matchers::AliasedNegatedMatcher::DefaultFailureMessages = RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
RSpec::Matchers::BE_PREDICATE_REGEX = T.let(T.unsafe(nil), Regexp)

# Container module for all built-in matchers. The matcher classes are here
# (rather than directly under `RSpec::Matchers`) in order to prevent name
# collisions, since `RSpec::Matchers` gets included into the user's namespace.
#
# Autoloading is used to delay when the matcher classes get loaded, allowing
# rspec-matchers to boot faster, and avoiding loading matchers the user is
# not using.
module RSpec::Matchers::BuiltIn; end

# Provides the implementation for `all`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::All < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [All] a new instance of All
  def initialize(matcher); end

  # @api private
  # @return [String]
  def description; end

  # @api private
  # @private
  # @raise [NotImplementedError]
  # @return [Boolean]
  def does_not_match?(_actual); end

  # @api private
  # @private
  def failed_objects; end

  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @private
  def matcher; end

  private

  # @api private
  def add_new_line_if_needed(message); end

  # @api private
  def failure_message_for_item(index, failure_message); end

  # @api private
  def indent_multiline_message(message); end

  # @api private
  def index_failed_objects; end

  # @api private
  def initialize_copy(other); end

  # @api private
  # @return [Boolean]
  def iterable?; end

  # @api private
  def match(_expected, _actual); end
end

# Used _internally_ as a base class for matchers that ship with
# rspec-expectations and rspec-rails.
#
# ### Warning:
#
# This class is for internal use, and subject to change without notice.
# We strongly recommend that you do not base your custom matchers on this
# class. If/when this changes, we will announce it and remove this warning.
#
# @api private
class RSpec::Matchers::BuiltIn::BaseMatcher
  include ::RSpec::Matchers::Composable
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages

  # @api private
  # @return [BaseMatcher] a new instance of BaseMatcher
  def initialize(expected = T.unsafe(nil)); end

  # @api private
  # @private
  def actual; end

  # @api private
  # @private
  def actual_formatted; end

  # Generates a description using {EnglishPhrasing}.
  #
  # @api private
  # @return [String]
  def description; end

  # Matchers are not diffable by default. Override this to make your
  # subclass diffable.
  #
  # @api private
  # @return [Boolean]
  def diffable?; end

  # @api private
  # @private
  def expected; end

  # @api private
  # @private
  def expected_formatted; end

  # @api private
  # @return [Boolean]
  def expects_call_stack_jump?; end

  # Used to wrap a block of code that will indicate failure by
  # raising one of the named exceptions.
  #
  # This is used by rspec-rails for some of its matchers that
  # wrap rails' assertions.
  #
  # @api private
  def match_unless_raises(*exceptions); end

  # @api private
  # @private
  def matcher_name; end

  # @api private
  # @private
  def matcher_name=(_arg0); end

  # Indicates if the match is successful. Delegates to `match`, which
  # should be defined on a subclass. Takes care of consistently
  # initializing the `actual` attribute.
  #
  # @api private
  # @return [Boolean]
  def matches?(actual); end

  # :nocov:
  #
  # @api private
  def present_ivars; end

  # @api private
  # @private
  def rescued_exception; end

  # Most matchers are value matchers (i.e. meant to work with `expect(value)`)
  # rather than block matchers (i.e. meant to work with `expect { }`), so
  # this defaults to false. Block matchers must override this to return true.
  #
  # @api private
  # @return [Boolean]
  def supports_block_expectations?; end

  # @api private
  # @private
  # @return [Boolean]
  def supports_value_expectations?; end

  private

  # @api private
  def assert_ivars(*expected_ivars); end

  class << self
    # @api private
    # @private
    def matcher_name; end

    private

    # Borrowed from ActiveSupport.
    #
    # @api private
    # @private
    def underscore(camel_cased_word); end
  end
end

# Provides default implementations of failure messages, based on the `description`.
#
# @api private
module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  # Provides a good generic failure message. Based on `description`.
  # When subclassing, if you are not satisfied with this failure message
  # you often only need to override `description`.
  #
  # @api private
  # @return [String]
  def failure_message; end

  # Provides a good generic negative failure message. Based on `description`.
  # When subclassing, if you are not satisfied with this failure message
  # you often only need to override `description`.
  #
  # @api private
  # @return [String]
  def failure_message_when_negated; end

  class << self
    # @api private
    # @private
    # @return [Boolean]
    def has_default_failure_messages?(matcher); end
  end
end

# @api private
# @private
module RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  private

  # `{ :a => 5, :b => 2 }.inspect` produces:
  #
  #     {:a=>5, :b=>2}
  #
  # ...but it looks much better as:
  #
  #     {:a => 5, :b => 2}
  #
  # This is idempotent and safe to run on a string multiple times.
  #
  # @api private
  def improve_hash_formatting(inspect_string); end

  class << self
    # `{ :a => 5, :b => 2 }.inspect` produces:
    #
    #     {:a=>5, :b=>2}
    #
    # ...but it looks much better as:
    #
    #     {:a => 5, :b => 2}
    #
    # This is idempotent and safe to run on a string multiple times.
    #
    # @api private
    def improve_hash_formatting(inspect_string); end
  end
end

# Used to detect when no arg is passed to `initialize`.
# `nil` cannot be used because it's a valid value to pass.
#
# @api private
RSpec::Matchers::BuiltIn::BaseMatcher::UNDEFINED = T.let(T.unsafe(nil), Object)

# Provides the implementation for `be`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::Be < ::RSpec::Matchers::BuiltIn::BaseMatcher
  include ::RSpec::Matchers::BuiltIn::BeHelpers

  # @api private
  # @return [Be] a new instance of Be
  def initialize(*args); end

  def <(operand); end
  def <=(operand); end
  def ==(operand); end
  def ===(operand); end
  def =~(operand); end
  def >(operand); end
  def >=(operand); end

  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  private

  # @api private
  def match(_, actual); end
end

# Provides the implementation for `be_a_kind_of`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::BeAKindOf < ::RSpec::Matchers::BuiltIn::BaseMatcher
  private

  # @api private
  def match(expected, actual); end
end

# Provides the implementation for `be_an_instance_of`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::BeAnInstanceOf < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [String]
  def description; end

  private

  # @api private
  def match(expected, actual); end
end

# Provides the implementation for `be_between`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::BeBetween < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [BeBetween] a new instance of BeBetween
  def initialize(min, max); end

  # @api private
  # @return [String]
  def description; end

  # Makes the between comparison exclusive.
  #
  # @api public
  # @example
  #   expect(3).to be_between(2, 4).exclusive
  def exclusive; end

  # @api private
  # @return [String]
  def failure_message; end

  # Makes the between comparison inclusive.
  #
  # @api public
  # @example
  #   expect(3).to be_between(2, 3).inclusive
  # @note The matcher is inclusive by default; this simply provides
  #   a way to be more explicit about it.
  def inclusive; end

  # @api private
  # @return [Boolean]
  def matches?(actual); end

  private

  # @api private
  # @return [Boolean]
  def comparable?; end

  # @api private
  def compare; end

  # @api private
  def not_comparable_clause; end
end

# Provides the implementation of `be <operator> value`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::BeComparedTo < ::RSpec::Matchers::BuiltIn::BaseMatcher
  include ::RSpec::Matchers::BuiltIn::BeHelpers

  # @api private
  # @return [BeComparedTo] a new instance of BeComparedTo
  def initialize(operand, operator); end

  # @api private
  # @return [String]
  def description; end

  # @api private
  # @return [Boolean]
  def does_not_match?(actual); end

  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  # @api private
  # @return [Boolean]
  def matches?(actual); end

  private

  # @api private
  def perform_match(actual); end
end

# Provides the implementation for `be_falsey`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::BeFalsey < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  private

  # @api private
  def match(_, actual); end
end

# @private
module RSpec::Matchers::BuiltIn::BeHelpers
  private

  def args_to_s; end
  def args_to_sentence; end
  def expected_to_sentence; end
  def inspected_args; end
  def parenthesize(string); end
end

# Provides the implementation for `be_nil`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::BeNil < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  private

  # @api private
  def match(_, actual); end
end

# Provides the implementation of `be_<predicate>`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::BePredicate < ::RSpec::Matchers::BuiltIn::DynamicPredicate
  private

  # @api private
  def failure_to_respond_explanation; end

  # @api private
  def predicate; end

  # @api private
  # @return [Boolean]
  def predicate_accessible?; end

  # @api private
  def predicate_method_name; end

  # @api private
  def present_tense_predicate; end
end

# @api private
RSpec::Matchers::BuiltIn::BePredicate::REGEX = T.let(T.unsafe(nil), Regexp)

# Provides the implementation for `be_truthy`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::BeTruthy < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  private

  # @api private
  def match(_, actual); end
end

# Provides the implementation for `be_within`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::BeWithin < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [BeWithin] a new instance of BeWithin
  def initialize(delta); end

  # @api private
  # @return [String]
  def description; end

  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  # @api private
  # @private
  # @return [Boolean]
  def matches?(actual); end

  # Sets the expected value.
  #
  # @api public
  def of(expected); end

  # Sets the expected value, and makes the matcher do
  # a percent comparison.
  #
  # @api public
  def percent_of(expected); end

  private

  # @api private
  def needs_expected; end

  # @api private
  def not_numeric_clause; end

  # @api private
  # @return [Boolean]
  def numeric?; end
end

# @private
module RSpec::Matchers::BuiltIn::CaptureStderr
  class << self
    def capture(block); end
    def name; end
  end
end

# @private
module RSpec::Matchers::BuiltIn::CaptureStdout
  class << self
    def capture(block); end
    def name; end
  end
end

# @private
class RSpec::Matchers::BuiltIn::CaptureStreamToTempfile < ::Struct
  def capture(block); end
end

# Provides the implementation for `change`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::Change < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [Change] a new instance of Change
  def initialize(receiver = T.unsafe(nil), message = T.unsafe(nil), &block); end

  # Specifies the delta of the expected change.
  #
  # @api public
  def by(expected_delta); end

  # Specifies a minimum delta of the expected change.
  #
  # @api public
  def by_at_least(minimum); end

  # Specifies a maximum delta of the expected change.
  #
  # @api public
  def by_at_most(maximum); end

  # @api private
  # @return [String]
  def description; end

  # @api private
  # @return [Boolean]
  def does_not_match?(event_proc); end

  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  # Specifies the original value.
  #
  # @api public
  def from(value); end

  # @api private
  # @private
  # @return [Boolean]
  def matches?(event_proc); end

  # @api private
  # @private
  # @return [Boolean]
  def supports_block_expectations?; end

  # @api private
  # @private
  # @return [Boolean]
  def supports_value_expectations?; end

  # Specifies the new value you expect.
  #
  # @api public
  def to(value); end

  private

  # @api private
  def change_details; end

  # @api private
  def negative_failure_reason; end

  # @api private
  def perform_change(event_proc); end

  # @api private
  def positive_failure_reason; end

  # @api private
  # @raise [SyntaxError]
  def raise_block_syntax_error; end
end

# Encapsulates the details of the before/after values.
#
# Note that this class exposes the `actual_after` value, to allow the
# matchers above to derive failure messages, etc from the value on demand
# as needed, but it intentionally does _not_ expose the `actual_before`
# value. Some usages of the `change` matcher mutate a specific object
# returned by the value proc, which means that failure message snippets,
# etc, which are derived from the `before` value may not be accurate if
# they are lazily computed as needed. We must pre-compute them before
# applying the change in the `expect` block. To ensure that all `change`
# matchers do that properly, we do not expose the `actual_before` value.
# Instead, matchers must pass a block to `perform_change`, which yields
# the `actual_before` value before applying the change.
#
# @private
class RSpec::Matchers::BuiltIn::ChangeDetails
  # @return [ChangeDetails] a new instance of ChangeDetails
  def initialize(matcher_name, receiver = T.unsafe(nil), message = T.unsafe(nil), &block); end

  # Returns the value of attribute actual_after.
  def actual_after; end

  def actual_delta; end

  # @return [Boolean]
  def changed?; end

  # @yield [@actual_before]
  def perform_change(event_proc); end

  def value_representation; end

  private

  def evaluate_value_proc; end
  def extract_value_block_snippet; end
  def message_notation(receiver, message); end
end

module RSpec::Matchers::BuiltIn::ChangeDetails::UNDEFINED; end

# Used to specify a change from a specific value
# (and, optionally, to a specific value).
#
# @api private
class RSpec::Matchers::BuiltIn::ChangeFromValue < ::RSpec::Matchers::BuiltIn::SpecificValuesChange
  # @api private
  # @return [ChangeFromValue] a new instance of ChangeFromValue
  def initialize(change_details, expected_before); end

  # @api private
  # @private
  # @return [Boolean]
  def does_not_match?(event_proc); end

  # @api private
  # @private
  def failure_message_when_negated; end

  # Specifies the new value you expect.
  #
  # @api public
  def to(value); end

  private

  # @api private
  def change_description; end
end

# Used to specify a relative change.
#
# @api private
class RSpec::Matchers::BuiltIn::ChangeRelatively < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [ChangeRelatively] a new instance of ChangeRelatively
  def initialize(change_details, expected_delta, relativity, &comparer); end

  # @api private
  # @private
  def description; end

  # @api private
  # @private
  # @raise [NotImplementedError]
  # @return [Boolean]
  def does_not_match?(_event_proc); end

  # @api private
  # @private
  def failure_message; end

  # @api private
  # @private
  # @return [Boolean]
  def matches?(event_proc); end

  # @api private
  # @private
  # @return [Boolean]
  def supports_block_expectations?; end

  # @api private
  # @private
  # @return [Boolean]
  def supports_value_expectations?; end

  private

  # @api private
  def failure_reason; end
end

# Used to specify a change to a specific value
# (and, optionally, from a specific value).
#
# @api private
class RSpec::Matchers::BuiltIn::ChangeToValue < ::RSpec::Matchers::BuiltIn::SpecificValuesChange
  # @api private
  # @return [ChangeToValue] a new instance of ChangeToValue
  def initialize(change_details, expected_after); end

  # @api private
  # @private
  # @raise [NotImplementedError]
  # @return [Boolean]
  def does_not_match?(_event_proc); end

  # Specifies the original value.
  #
  # @api public
  def from(value); end

  private

  # @api private
  def change_description; end
end

# Base class for `and` and `or` compound matchers.
#
# @api private
class RSpec::Matchers::BuiltIn::Compound < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [Compound] a new instance of Compound
  def initialize(matcher_1, matcher_2); end

  # @api private
  # @return [String]
  def description; end

  # @api private
  # @return [Boolean]
  def diffable?; end

  # @api private
  # @private
  # @raise [NotImplementedError]
  # @return [Boolean]
  def does_not_match?(_actual); end

  # @api private
  # @private
  def evaluator; end

  # @api private
  # @return [RSpec::Matchers::ExpectedsForMultipleDiffs]
  def expected; end

  # @api private
  # @return [Boolean]
  def expects_call_stack_jump?; end

  # @api private
  # @private
  def matcher_1; end

  # @api private
  # @private
  def matcher_2; end

  # @api private
  # @return [Boolean]
  def supports_block_expectations?; end

  # @api private
  # @return [Boolean]
  def supports_value_expectations?; end

  protected

  # @api private
  def diffable_matcher_list; end

  private

  # @api private
  def compound_failure_message; end

  # @api private
  def diffable_matcher_list_for(matcher); end

  # @api private
  def indent_multiline_message(message); end

  # @api private
  def initialize_copy(other); end

  # @api private
  def match(_expected, actual); end

  # @api private
  # @return [Boolean]
  def matcher_1_matches?; end

  # @api private
  # @return [Boolean]
  def matcher_2_matches?; end

  # @api private
  # @return [Boolean]
  def matcher_is_diffable?(matcher); end

  # @api private
  # @return [Boolean]
  def matcher_supports_block_expectations?(matcher); end

  # @api private
  # @return [Boolean]
  def matcher_supports_value_expectations?(matcher); end
end

# Matcher used to represent a compound `and` expectation.
#
# @api public
class RSpec::Matchers::BuiltIn::Compound::And < ::RSpec::Matchers::BuiltIn::Compound
  # @api private
  # @return [String]
  def failure_message; end

  private

  # @api public
  def conjunction; end

  # @api public
  def match(*_arg0); end
end

# Normally, we evaluate the matching sequentially. For an expression like
# `expect(x).to foo.and bar`, this becomes:
#
#   expect(x).to foo
#   expect(x).to bar
#
# For block expectations, we need to nest them instead, so that
# `expect { x }.to foo.and bar` becomes:
#
#   expect {
#     expect { x }.to foo
#   }.to bar
#
# This is necessary so that the `expect` block is only executed once.
#
# @api private
class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  # @api private
  # @return [NestedEvaluator] a new instance of NestedEvaluator
  def initialize(actual, matcher_1, matcher_2); end

  # @api private
  # @return [Boolean]
  def matcher_matches?(matcher); end

  private

  # Some block matchers (such as `yield_xyz`) pass args to the `expect` block.
  # When such a matcher is used as the outer matcher, we need to forward the
  # the args on to the `expect` block.
  #
  # @api private
  def inner_matcher_block(outer_args); end

  # For a matcher like `raise_error` or `throw_symbol`, where the block will jump
  # up the call stack, we need to order things so that it is the inner matcher.
  # For example, we need it to be this:
  #
  #   expect {
  #     expect {
  #       x += 1
  #       raise "boom"
  #     }.to raise_error("boom")
  #   }.to change { x }.by(1)
  #
  # ...rather than:
  #
  #   expect {
  #     expect {
  #       x += 1
  #       raise "boom"
  #     }.to change { x }.by(1)
  #   }.to raise_error("boom")
  #
  # In the latter case, the after-block logic in the `change` matcher would never
  # get executed because the `raise "boom"` line would jump to the `rescue` in the
  # `raise_error` logic, so only the former case will work properly.
  #
  # This method figures out which matcher should be the inner matcher and which
  # should be the outer matcher.
  #
  # @api private
  # @raise [ArgumentError]
  def order_block_matchers; end

  class << self
    # @api private
    # @return [Boolean]
    def matcher_expects_call_stack_jump?(matcher); end
  end
end

# Matcher used to represent a compound `or` expectation.
#
# @api public
class RSpec::Matchers::BuiltIn::Compound::Or < ::RSpec::Matchers::BuiltIn::Compound
  # @api private
  # @return [String]
  def failure_message; end

  private

  # @api public
  def conjunction; end

  # @api public
  def match(*_arg0); end
end

# For value expectations, we can evaluate the matchers sequentially.
#
# @api private
class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
  # @api private
  # @return [SequentialEvaluator] a new instance of SequentialEvaluator
  def initialize(actual, *_arg1); end

  # @api private
  # @return [Boolean]
  def matcher_matches?(matcher); end
end

# Provides the implementation for `contain_exactly` and `match_array`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::ContainExactly < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [String]
  def description; end

  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  private

  # @api private
  def actual_collection_line; end

  # @api private
  def best_solution; end

  # @api private
  def convert_actual_to_an_array; end

  # @api private
  def describe_collection(collection, surface_descriptions = T.unsafe(nil)); end

  # @api private
  def expected_collection_line; end

  # @api private
  def extra_elements_line; end

  # @api private
  def extra_items; end

  # @api private
  def generate_failure_message; end

  # @api private
  def match(_expected, _actual); end

  # This cannot always work (e.g. when dealing with unsortable items,
  # or matchers as expected items), but it's practically free compared to
  # the slowness of the full matching algorithm, and in common cases this
  # works, so it's worth a try.
  #
  # @api private
  # @return [Boolean]
  def match_when_sorted?; end

  # @api private
  def message_line(prefix, collection, surface_descriptions = T.unsafe(nil)); end

  # @api private
  def missing_elements_line; end

  # @api private
  def missing_items; end

  # @api private
  def pairings_maximizer; end

  # @api private
  def safe_sort(array); end

  # @api private
  # @return [Boolean]
  def to_a_disallowed?(object); end
end

# Once we started supporting composing matchers, the algorithm for this matcher got
# much more complicated. Consider this expression:
#
#   expect(["fool", "food"]).to contain_exactly(/foo/, /fool/)
#
# This should pass (because we can pair /fool/ with "fool" and /foo/ with "food"), but
# the original algorithm used by this matcher would pair the first elements it could
# (/foo/ with "fool"), which would leave /fool/ and "food" unmatched.  When we have
# an expected element which is a matcher that matches a superset of actual items
# compared to another expected element matcher, we need to consider every possible pairing.
#
# This class is designed to maximize the number of actual/expected pairings -- or,
# conversely, to minimize the number of unpaired items. It's essentially a brute
# force solution, but with a few heuristics applied to reduce the size of the
# problem space:
#
#   * Any items which match none of the items in the other list are immediately
#     placed into the `unmatched_expected_indexes` or `unmatched_actual_indexes` array.
#     The extra items and missing items in the matcher failure message are derived
#     from these arrays.
#   * Any items which reciprocally match only each other are paired up and not
#     considered further.
#
# What's left is only the items which match multiple items from the other list
# (or vice versa). From here, it performs a brute-force depth-first search,
# looking for a solution which pairs all elements in both lists, or, barring that,
# that produces the fewest unmatched items.
#
# @api private
# @private
class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
  # @api private
  # @return [PairingsMaximizer] a new instance of PairingsMaximizer
  def initialize(expected_to_actual_matched_indexes, actual_to_expected_matched_indexes); end

  # @api private
  def actual_to_expected_matched_indexes; end

  # @api private
  def expected_to_actual_matched_indexes; end

  # @api private
  def find_best_solution; end

  # @api private
  def solution; end

  private

  # @api private
  def apply_pairing_to(indeterminates, original_matches, other_list_index); end

  # @api private
  def best_solution_for_pairing(expected_index, actual_index); end

  # @api private
  def categorize_indexes(indexes_to_categorize, other_indexes); end

  # @api private
  # @return [Boolean]
  def reciprocal_single_match?(matches, index, other_list); end
end

# Starting solution that is worse than any other real solution.
#
# @api private
# @private
class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
  class << self
    def worse_than?(_other); end
  end
end

# @api private
# @private
class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution < ::Struct
  # @api private
  def +(derived_candidate_solution); end

  # @api private
  # @return [Boolean]
  def candidate?; end

  # @api private
  # @return [Boolean]
  def ideal?; end

  # Returns the value of attribute indeterminate_actual_indexes
  #
  # @return [Object] the current value of indeterminate_actual_indexes
  def indeterminate_actual_indexes; end

  # Sets the attribute indeterminate_actual_indexes
  #
  # @param value [Object] the value to set the attribute indeterminate_actual_indexes to.
  # @return [Object] the newly set value
  def indeterminate_actual_indexes=(_); end

  # Returns the value of attribute indeterminate_expected_indexes
  #
  # @return [Object] the current value of indeterminate_expected_indexes
  def indeterminate_expected_indexes; end

  # Sets the attribute indeterminate_expected_indexes
  #
  # @param value [Object] the value to set the attribute indeterminate_expected_indexes to.
  # @return [Object] the newly set value
  def indeterminate_expected_indexes=(_); end

  # Returns the value of attribute unmatched_actual_indexes
  #
  # @return [Object] the current value of unmatched_actual_indexes
  def unmatched_actual_indexes; end

  # Sets the attribute unmatched_actual_indexes
  #
  # @param value [Object] the value to set the attribute unmatched_actual_indexes to.
  # @return [Object] the newly set value
  def unmatched_actual_indexes=(_); end

  # Returns the value of attribute unmatched_expected_indexes
  #
  # @return [Object] the current value of unmatched_expected_indexes
  def unmatched_expected_indexes; end

  # Sets the attribute unmatched_expected_indexes
  #
  # @param value [Object] the value to set the attribute unmatched_expected_indexes to.
  # @return [Object] the newly set value
  def unmatched_expected_indexes=(_); end

  # @api private
  def unmatched_item_count; end

  # @api private
  # @return [Boolean]
  def worse_than?(other); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Asbtract class to implement `once`, `at_least` and other
# count constraints.
#
# @api private
module RSpec::Matchers::BuiltIn::CountExpectation
  # Specifies the minimum number of times the method is expected to match
  #
  # @api public
  def at_least(number); end

  # Specifies the maximum number of times the method is expected to match
  #
  # @api public
  def at_most(number); end

  # Specifies that the method is expected to match the given number of times.
  #
  # @api public
  def exactly(number); end

  # Specifies that the method is expected to match once.
  #
  # @api public
  def once; end

  # Specifies that the method is expected to match thrice.
  #
  # @api public
  def thrice; end

  # No-op. Provides syntactic sugar.
  #
  # @api public
  def times; end

  # Specifies that the method is expected to match twice.
  #
  # @api public
  def twice; end

  protected

  # @api private
  def count_expectation_type; end

  # @api private
  def expected_count; end

  private

  # @api private
  def count_constraint_to_number(n); end

  # @api private
  def count_expectation_description; end

  # @api private
  def count_failure_reason(action); end

  # @api private
  # @return [Boolean]
  def cover?(count, number); end

  # @api private
  # @return [Boolean]
  def expected_count_matches?(actual_count); end

  # @api private
  # @return [Boolean]
  def has_expected_count?; end

  # @api private
  def human_readable_count(count); end

  # @api private
  def human_readable_expectation_type; end

  # @api private
  # @raise [ArgumentError]
  def raise_impossible_count_expectation(count); end

  # @api private
  # @raise [ArgumentError]
  def raise_unsupported_count_expectation; end

  # @api private
  def set_expected_count(relativity, n); end

  # @api private
  # @return [Boolean]
  def unsupported_count_expectation?(relativity); end
end

# Provides the implementation for `cover`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::Cover < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [Cover] a new instance of Cover
  def initialize(*expected); end

  # @api private
  # @return [Boolean]
  def does_not_match?(range); end

  # @api private
  # @return [Boolean]
  def matches?(range); end
end

# Provides the implementation for dynamic predicate matchers.
# Not intended to be inherited directly.
#
# @api private
class RSpec::Matchers::BuiltIn::DynamicPredicate < ::RSpec::Matchers::BuiltIn::BaseMatcher
  include ::RSpec::Matchers::BuiltIn::BeHelpers

  # @api private
  # @return [DynamicPredicate] a new instance of DynamicPredicate
  def initialize(method_name, *args, **_arg2, &block); end

  # @api private
  # @return [String]
  def description; end

  # @api private
  # @private
  # @return [Boolean]
  def does_not_match?(actual, &block); end

  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  # @api private
  # @private
  # @return [Boolean]
  def matches?(actual, &block); end

  private

  # @api private
  def expectation_of(value); end

  # @api private
  def failure_message_expecting(value); end

  # @api private
  def failure_to_respond_explanation; end

  # @api private
  def method_description; end

  # @api private
  # @return [Boolean]
  def predicate_accessible?; end

  # @api private
  # @return [Boolean]
  def predicate_matches?(value = T.unsafe(nil)); end

  # @api private
  def predicate_method_name; end

  # @api private
  def predicate_result; end

  # :nocov:
  #
  # @api private
  # @return [Boolean]
  def private_predicate?; end

  # @api private
  def root; end

  # @api private
  def validity_message; end
end

# Provides the implementation for `end_with`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::EndWith < ::RSpec::Matchers::BuiltIn::StartOrEndWith
  private

  # @api private
  # @return [Boolean]
  def element_matches?; end

  # @api private
  # @return [Boolean]
  def subset_matches?; end
end

# Provides the implementation for `eq`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::Eq < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [String]
  def description; end

  # @api private
  # @return [Boolean]
  def diffable?; end

  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  private

  # @api private
  def match(expected, actual); end
end

# Provides the implementation for `eql`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::Eql < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [Boolean]
  def diffable?; end

  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  private

  # @api private
  def match(expected, actual); end
end

# Provides the implementation for `equal`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::Equal < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [Boolean]
  def diffable?; end

  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  private

  # @api private
  def actual_inspected; end

  # @api private
  def detailed_failure_message; end

  # @api private
  # @return [Boolean]
  def expected_is_a_literal_singleton?; end

  # @api private
  def inspect_object(o); end

  # @api private
  def match(expected, actual); end

  # @api private
  def simple_failure_message; end
end

# @api private
RSpec::Matchers::BuiltIn::Equal::LITERAL_SINGLETONS = T.let(T.unsafe(nil), Array)

# Provides the implementation for `exist`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::Exist < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [Exist] a new instance of Exist
  def initialize(*expected); end

  # @api private
  # @return [Boolean]
  def does_not_match?(actual); end

  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  # @api private
  # @return [Boolean]
  def matches?(actual); end
end

# Simple class for memoizing actual/expected for this matcher
# and examining the match
#
# @api private
class RSpec::Matchers::BuiltIn::Exist::ExistenceTest < ::Struct
  # @api private
  # @return [Boolean]
  def actual_exists?; end

  # @api private
  # @return [Boolean]
  def valid_test?; end

  # @api private
  # @return [String]
  def validity_message; end

  private

  # @api private
  def deprecated(predicate, actual); end

  # @api private
  def existence_values; end

  # @api private
  def predicates; end

  # @api private
  def uniq_truthy_values; end
end

# Provides the implementation for `has_<predicate>`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::Has < ::RSpec::Matchers::BuiltIn::DynamicPredicate
  private

  # @api private
  def predicate; end
end

# @api private
RSpec::Matchers::BuiltIn::Has::REGEX = T.let(T.unsafe(nil), Regexp)

# Provides the implementation for `have_attributes`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::HaveAttributes < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [HaveAttributes] a new instance of HaveAttributes
  def initialize(expected); end

  # @api private
  # @private
  def actual; end

  # @api private
  # @return [String]
  def description; end

  # @api private
  # @return [Boolean]
  def diffable?; end

  # @api private
  # @return [Boolean]
  def does_not_match?(actual); end

  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  # @api private
  # @return [Boolean]
  def matches?(actual); end

  # @api private
  # @private
  def respond_to_failed; end

  private

  # @api private
  # @return [Boolean]
  def actual_has_attribute?(attribute_key, attribute_value); end

  # @api private
  def cache_all_values; end

  # @api private
  def formatted_values; end

  # @api private
  def perform_match(predicate); end

  # @api private
  # @return [Boolean]
  def respond_to_attributes?; end

  # @api private
  def respond_to_failure_message_or; end

  # @api private
  def respond_to_matcher; end
end

# Provides the implementation for `include`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::Include < ::RSpec::Matchers::BuiltIn::BaseMatcher
  include ::RSpec::Matchers::BuiltIn::CountExpectation

  # @api private
  # @return [Include] a new instance of Include
  def initialize(*expecteds); end

  # @api private
  # @return [String]
  def description; end

  # @api private
  # @return [Boolean]
  def diffable?; end

  # @api private
  # @return [Boolean]
  def does_not_match?(actual); end

  # @api private
  # @return [Array, Hash]
  def expected; end

  # @api private
  # @private
  def expecteds; end

  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  # @api private
  # @return [Boolean]
  def matches?(actual); end

  private

  # @api private
  # @return [Boolean]
  def actual_collection_includes?(expected_item); end

  # @api private
  # @return [Boolean]
  def actual_hash_has_key?(expected_key); end

  # @api private
  # @return [Boolean]
  def actual_hash_includes?(expected_key, expected_value); end

  # @api private
  # @return [Boolean]
  def check_actual?(actual); end

  # @api private
  # @return [Boolean]
  def check_expected_count?; end

  # @api private
  # @return [Boolean]
  def comparing_hash_keys?(expected_item); end

  # @api private
  # @return [Boolean]
  def comparing_hash_to_a_subset?(expected_item); end

  # @api private
  # @return [Boolean]
  def convert_to_hash?(obj); end

  # @api private
  def count_enumerable(expected_item); end

  # @api private
  def count_inclusions; end

  # @api private
  # @return [Boolean]
  def diff_would_wrongly_highlight_matched_item?; end

  # @api private
  def excluded_from_actual; end

  # @api private
  def format_failure_message(preposition); end

  # @api private
  def perform_match(&block); end

  # @api private
  def readable_list_of(items); end
end

# Provides the implementation for `match`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::Match < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [Match] a new instance of Match
  def initialize(expected); end

  # @api private
  # @return [String]
  def description; end

  # @api private
  # @return [Boolean]
  def diffable?; end

  # Used to specify the captures we match against
  #
  # @api private
  # @return [self]
  def with_captures(*captures); end

  private

  # @api private
  # @return [Boolean]
  def can_safely_call_match?(expected, actual); end

  # @api private
  def match(expected, actual); end

  # @api private
  def match_captures(expected, actual); end
end

# Handles operator matcher for `should_not`.
#
# @private
class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher < ::RSpec::Matchers::BuiltIn::OperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

# @private
module RSpec::Matchers::BuiltIn::NullCapture
  class << self
    def capture(_block); end
    def name; end
  end
end

# Provides the implementation for operator matchers.
# Not intended to be instantiated directly.
# Only available for use with `should`.
#
# @api private
class RSpec::Matchers::BuiltIn::OperatorMatcher
  # @api private
  # @return [OperatorMatcher] a new instance of OperatorMatcher
  def initialize(actual); end

  def !=(_expected); end
  def !~(_expected); end
  def <(expected); end
  def <=(expected); end
  def ==(expected); end
  def ===(expected); end
  def =~(expected); end
  def >(expected); end
  def >=(expected); end

  # @api private
  # @return [String]
  def description; end

  # @api private
  # @private
  def fail_with_message(message); end

  private

  # @api private
  def eval_match(actual, operator, expected); end

  # @api private
  # @return [Boolean]
  def has_non_generic_implementation_of?(op); end

  class << self
    # @api private
    # @private
    def get(klass, operator); end

    # @api private
    # @private
    def register(klass, operator, matcher); end

    # @api private
    # @private
    def registry; end

    # @api private
    # @private
    def unregister(klass, operator); end

    # @api private
    # @private
    def use_custom_matcher_or_delegate(operator); end
  end
end

# Provides the implementation for `output`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::Output < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [Output] a new instance of Output
  def initialize(expected); end

  # @api private
  # @return [String]
  def description; end

  # @api private
  # @return [Boolean]
  def diffable?; end

  # @api private
  # @return [Boolean]
  def does_not_match?(block); end

  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  # @api private
  # @return [Boolean]
  def matches?(block); end

  # Indicates this matcher matches against a block.
  #
  # @api private
  # @return [True]
  def supports_block_expectations?; end

  # Indicates this matcher matches against a block only.
  #
  # @api private
  # @return [False]
  def supports_value_expectations?; end

  # Tells the matcher to match against stderr.
  # Works only when the main Ruby process prints to stderr
  #
  # @api public
  def to_stderr; end

  # Tells the matcher to match against stderr.
  # Works when subprocesses print to stderr as well.
  # This is significantly (~30x) slower than `to_stderr`
  #
  # @api public
  def to_stderr_from_any_process; end

  # Tells the matcher to match against stdout.
  # Works only when the main Ruby process prints to stdout
  #
  # @api public
  def to_stdout; end

  # Tells the matcher to match against stdout.
  # Works when subprocesses print to stdout as well.
  # This is significantly (~30x) slower than `to_stdout`
  #
  # @api public
  def to_stdout_from_any_process; end

  private

  # @api private
  def actual_output_description; end

  # @api private
  # @return [Boolean]
  def captured?; end

  # @api private
  def negative_failure_reason; end

  # @api private
  def positive_failure_reason; end
end

# Handles operator matcher for `should`.
#
# @private
class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher < ::RSpec::Matchers::BuiltIn::OperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

# Provides the implementation for `raise_error`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::RaiseError
  include ::RSpec::Matchers::Composable

  # @api private
  # @return [RaiseError] a new instance of RaiseError
  def initialize(expected_error_or_message, expected_message, &block); end

  # @api private
  # @return [String]
  def description; end

  # @api private
  # @private
  # @return [Boolean]
  def does_not_match?(given_proc); end

  # @api private
  # @private
  # @return [Boolean]
  def expects_call_stack_jump?; end

  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  # @api private
  # @private
  # @return [Boolean]
  def matches?(given_proc, negative_expectation = T.unsafe(nil), &block); end

  # @api private
  # @private
  # @return [Boolean]
  def supports_block_expectations?; end

  # @api private
  # @private
  # @return [Boolean]
  def supports_value_expectations?; end

  # Specifies the expected error message.
  #
  # @api public
  def with_message(expected_message); end

  private

  # @api private
  def actual_error_message; end

  # @api private
  # @return [Boolean]
  def block_matches?; end

  # @api private
  # @return [Boolean]
  def error_and_message_match?; end

  # @api private
  def eval_block; end

  # @api private
  # @return [Boolean]
  def expectation_matched?; end

  # @api private
  def expected_error; end

  # @api private
  # @return [Boolean]
  def expecting_specific_exception?; end

  # @api private
  def format_backtrace(backtrace); end

  # @api private
  def given_error; end

  # @api private
  def handle_warning(message); end

  # @api private
  def raise_message_already_set; end

  # @api private
  # @return [Boolean]
  def ready_to_eval_block?; end

  # @api private
  def verify_message; end

  # @api private
  def warn_about_bare_error!; end

  # @api private
  # @return [Boolean]
  def warn_about_bare_error?; end

  # @api private
  def warn_about_negative_false_positive!(expression); end

  # @api private
  def warn_about_nil_error!; end

  # @api private
  # @return [Boolean]
  def warn_about_nil_error?; end

  # @api private
  def warn_for_negative_false_positives!; end

  # @api private
  def warning; end
end

# Used as a sentinel value to be able to tell when the user did not pass an
# argument. We can't use `nil` for that because we need to warn when `nil` is
# passed in a different way. It's an Object, not a Module, since Module's `===`
# does not evaluate to true when compared to itself.
#
# @api private
RSpec::Matchers::BuiltIn::RaiseError::UndefinedValue = T.let(T.unsafe(nil), Object)

# Used to wrap match data and make it reliable for 1.8.7
#
# @api private
class RSpec::Matchers::BuiltIn::ReliableMatchData
  # @api private
  # @return [ReliableMatchData] a new instance of ReliableMatchData
  def initialize(match_data); end

  # returns an array of captures from the match data
  #
  # @api private
  # @return Array
  def captures; end

  # Returns match data names for named captures
  #
  # @api private
  # @return Array
  def names; end

  protected

  # @api private
  def match_data; end
end

# Provides the implementation for `respond_to`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::RespondTo < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [RespondTo] a new instance of RespondTo
  def initialize(*names); end

  # Specifies that the method accepts any keyword, i.e. the method has
  #   a splatted keyword parameter of the form **kw_args.
  #
  # @api public
  # @example
  #   expect(obj).to respond_to(:message).with_any_keywords
  def and_any_keywords; end

  # Specifies keyword arguments, if any.
  #
  # @api public
  # @example
  #   expect(obj).to respond_to(:message).with_keywords(:color, :shape)
  # @example with an expected number of arguments
  #   expect(obj).to respond_to(:message).with(3).arguments.and_keywords(:color, :shape)
  def and_keywords(*keywords); end

  # Specifies that the number of arguments has no upper limit, i.e. the
  #   method has a splatted parameter of the form *args.
  #
  # @api public
  # @example
  #   expect(obj).to respond_to(:message).with_unlimited_arguments
  def and_unlimited_arguments; end

  # No-op. Intended to be used as syntactic sugar when using `with`.
  #
  # @api public
  # @example
  #   expect(obj).to respond_to(:message).with(3).arguments
  def argument; end

  # No-op. Intended to be used as syntactic sugar when using `with`.
  #
  # @api public
  # @example
  #   expect(obj).to respond_to(:message).with(3).arguments
  def arguments; end

  # @api private
  # @return [String]
  def description; end

  # @api private
  # @private
  # @return [Boolean]
  def does_not_match?(actual); end

  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  # Used by other matchers to suppress a check
  #
  # @api private
  def ignoring_method_signature_failure!; end

  # @api private
  # @private
  # @return [Boolean]
  def matches?(actual); end

  # Specifies the number of expected arguments.
  #
  # @api public
  # @example
  #   expect(obj).to respond_to(:message).with(3).arguments
  def with(n); end

  # Specifies that the method accepts any keyword, i.e. the method has
  #   a splatted keyword parameter of the form **kw_args.
  #
  # @api public
  # @example
  #   expect(obj).to respond_to(:message).with_any_keywords
  def with_any_keywords; end

  # Specifies keyword arguments, if any.
  #
  # @api public
  # @example
  #   expect(obj).to respond_to(:message).with_keywords(:color, :shape)
  # @example with an expected number of arguments
  #   expect(obj).to respond_to(:message).with(3).arguments.and_keywords(:color, :shape)
  def with_keywords(*keywords); end

  # Specifies that the number of arguments has no upper limit, i.e. the
  #   method has a splatted parameter of the form *args.
  #
  # @api public
  # @example
  #   expect(obj).to respond_to(:message).with_unlimited_arguments
  def with_unlimited_arguments; end

  private

  # @api private
  def find_failing_method_names(actual, filter_method); end

  # @api private
  # @return [Boolean]
  def matches_arity?(actual, name); end

  # @api private
  def pp_names; end

  # @api private
  def with_arity; end

  # @api private
  def with_arity_string; end

  # @api private
  def with_keywords_string; end
end

# @api private
# @private
class RSpec::Matchers::BuiltIn::RespondTo::ArityCheck
  # @api private
  # @return [ArityCheck] a new instance of ArityCheck
  def initialize(expected_arity, expected_keywords, arbitrary_keywords, unlimited_arguments); end

  # @api private
  # @return [Boolean]
  def matches?(actual, name); end

  # @api private
  def method_signature_for(actual, name); end

  # @api private
  def verifier_for(actual, name); end
end

# Provides the implementation for `satisfy`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::Satisfy < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [Satisfy] a new instance of Satisfy
  def initialize(description = T.unsafe(nil), &block); end

  # @api private
  # @private
  def description; end

  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  # @api private
  # @private
  # @return [Boolean]
  def matches?(actual, &block); end

  private

  # @api private
  def block_representation; end

  # @api private
  def extract_block_snippet; end
end

# Base class for specifying a change from and/or to specific values.
#
# @api private
class RSpec::Matchers::BuiltIn::SpecificValuesChange < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [SpecificValuesChange] a new instance of SpecificValuesChange
  def initialize(change_details, from, to); end

  # @api private
  # @private
  def description; end

  # @api private
  # @private
  def failure_message; end

  # @api private
  # @private
  # @return [Boolean]
  def matches?(event_proc); end

  # @api private
  # @private
  # @return [Boolean]
  def supports_block_expectations?; end

  # @api private
  # @private
  # @return [Boolean]
  def supports_value_expectations?; end

  private

  # @api private
  def after_value_failure; end

  # @api private
  def before_value_failure; end

  # @api private
  def did_change_failure; end

  # @api private
  def did_not_change_failure; end

  # @api private
  # @return [Boolean]
  def matches_after?; end

  # @api private
  def not_given_a_block_failure; end

  # @api private
  def perform_change(event_proc); end
end

# @api private
# @private
RSpec::Matchers::BuiltIn::SpecificValuesChange::MATCH_ANYTHING = BasicObject

# For RSpec 3.1, the base class was named `StartAndEndWith`. For SemVer reasons,
# we still provide this constant until 4.0.
#
# @deprecated Use StartOrEndWith instead.
# @private
RSpec::Matchers::BuiltIn::StartAndEndWith = RSpec::Matchers::BuiltIn::StartOrEndWith

# Base class for the `end_with` and `start_with` matchers.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::StartOrEndWith < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [StartOrEndWith] a new instance of StartOrEndWith
  def initialize(*expected); end

  # @api private
  # @return [String]
  def description; end

  # @api private
  # @return [String]
  def failure_message; end

  private

  # @api private
  def match(_expected, actual); end

  # @api private
  # @return [Boolean]
  def subsets_comparable?; end
end

# Provides the implementation for `start_with`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::StartWith < ::RSpec::Matchers::BuiltIn::StartOrEndWith
  private

  # @api private
  # @return [Boolean]
  def element_matches?; end

  # @api private
  # @return [Boolean]
  def subset_matches?; end
end

# Provides the implementation for `throw_symbol`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::ThrowSymbol
  include ::RSpec::Matchers::Composable

  # @api private
  # @return [ThrowSymbol] a new instance of ThrowSymbol
  def initialize(expected_symbol = T.unsafe(nil), expected_arg = T.unsafe(nil)); end

  # @api private
  # @return [String]
  def description; end

  # @api private
  # @return [Boolean]
  def does_not_match?(given_proc); end

  # @api private
  # @return [Boolean]
  def expects_call_stack_jump?; end

  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  # @api private
  # @private
  # @return [Boolean]
  def matches?(given_proc); end

  # Indicates this matcher matches against a block.
  #
  # @api private
  # @return [True]
  def supports_block_expectations?; end

  # @api private
  # @return [Boolean]
  def supports_value_expectations?; end

  private

  # @api private
  def actual_result; end

  # @api private
  def caught; end

  # @api private
  def expected(symbol_desc = T.unsafe(nil)); end

  # @api private
  def throw_description(symbol, arg); end
end

# Provides the implementation for `yield_control`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::YieldControl < ::RSpec::Matchers::BuiltIn::BaseMatcher
  include ::RSpec::Matchers::BuiltIn::CountExpectation

  # @api private
  # @private
  # @return [Boolean]
  def does_not_match?(block); end

  # @api private
  # @return [String]
  def failure_message; end

  # @api private
  # @return [String]
  def failure_message_when_negated; end

  # @api private
  # @private
  # @return [Boolean]
  def matches?(block); end

  # @api private
  # @private
  # @return [Boolean]
  def supports_block_expectations?; end

  # @api private
  # @private
  # @return [Boolean]
  def supports_value_expectations?; end

  private

  # @api private
  def failure_reason; end
end

# Object that is yielded to `expect` when one of the
# yield matchers is used. Provides information about
# the yield behavior of the object-under-test.
#
# @private
class RSpec::Matchers::BuiltIn::YieldProbe
  # @return [YieldProbe] a new instance of YieldProbe
  def initialize(block, &callback); end

  def assert_used!; end

  # :nocov:
  # On 1.8.7, `lambda { }.arity` and `lambda { |*a| }.arity` both return -1,
  # so we can't distinguish between accepting no args and an arg splat.
  # It's OK to skip, this, though; it just provides a nice error message
  # when the user forgets to accept an arg in their block. They'll still get
  # the `assert_used!` error message from above, which is sufficient.
  def assert_valid_expect_block!; end

  # @return [Boolean]
  def has_block?; end

  # Returns the value of attribute num_yields.
  def num_yields; end

  # Sets the attribute num_yields
  #
  # @param value the value to set the attribute num_yields to.
  def num_yields=(_arg0); end

  def probe; end
  def single_yield_args; end
  def to_proc; end

  # Returns the value of attribute yielded_args.
  def yielded_args; end

  # Sets the attribute yielded_args
  #
  # @param value the value to set the attribute yielded_args to.
  def yielded_args=(_arg0); end

  # @return [Boolean]
  def yielded_once?(matcher_name); end

  class << self
    def probe(block, &callback); end
  end
end

# Provides the implementation for `yield_successive_args`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [YieldSuccessiveArgs] a new instance of YieldSuccessiveArgs
  def initialize(*args); end

  # @api private
  # @private
  def description; end

  # @api private
  # @return [Boolean]
  def does_not_match?(block); end

  # @api private
  # @private
  def failure_message; end

  # @api private
  # @private
  def failure_message_when_negated; end

  # @api private
  # @private
  # @return [Boolean]
  def matches?(block); end

  # @api private
  # @private
  # @return [Boolean]
  def supports_block_expectations?; end

  # @api private
  # @private
  # @return [Boolean]
  def supports_value_expectations?; end

  private

  # @api private
  def expected_arg_description; end

  # @api private
  def negative_failure_reason; end

  # @api private
  def positive_failure_reason; end
end

# Provides the implementation for `yield_with_args`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::YieldWithArgs < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @return [YieldWithArgs] a new instance of YieldWithArgs
  def initialize(*args); end

  # @api private
  # @private
  def description; end

  # @api private
  # @private
  # @return [Boolean]
  def does_not_match?(block); end

  # @api private
  # @private
  def failure_message; end

  # @api private
  # @private
  def failure_message_when_negated; end

  # @api private
  # @private
  # @return [Boolean]
  def matches?(block); end

  # @api private
  # @private
  # @return [Boolean]
  def supports_block_expectations?; end

  # @api private
  # @private
  # @return [Boolean]
  def supports_value_expectations?; end

  private

  # @api private
  # @return [Boolean]
  def all_args_match?; end

  # @api private
  # @return [Boolean]
  def args_currently_match?; end

  # @api private
  def expected_arg_description; end

  # @api private
  def negative_failure_reason; end

  # @api private
  def positive_failure_reason; end
end

# Provides the implementation for `yield_with_no_args`.
# Not intended to be instantiated directly.
#
# @api private
class RSpec::Matchers::BuiltIn::YieldWithNoArgs < ::RSpec::Matchers::BuiltIn::BaseMatcher
  # @api private
  # @private
  # @return [Boolean]
  def does_not_match?(block); end

  # @api private
  # @private
  def failure_message; end

  # @api private
  # @private
  def failure_message_when_negated; end

  # @api private
  # @private
  # @return [Boolean]
  def matches?(block); end

  # @api private
  # @private
  # @return [Boolean]
  def supports_block_expectations?; end

  # @api private
  # @private
  # @return [Boolean]
  def supports_value_expectations?; end

  private

  # @api private
  def negative_failure_reason; end

  # @api private
  def positive_failure_reason; end
end

# Mixin designed to support the composable matcher features
# of RSpec 3+. Mix it into your custom matcher classes to
# allow them to be used in a composable fashion.
#
# @api public
module RSpec::Matchers::Composable
  # Creates a compound `and` expectation. The matcher will
  # only pass if both sub-matchers pass.
  # This can be chained together to form an arbitrarily long
  # chain of matchers.
  #
  # @api public
  # @example
  #   expect(alphabet).to start_with("a").and end_with("z")
  #   expect(alphabet).to start_with("a") & end_with("z")
  # @note The negative form (`expect(...).not_to matcher.and other`)
  #   is not supported at this time.
  def &(matcher); end

  # Delegates to `#matches?`. Allows matchers to be used in composable
  # fashion and also supports using matchers in case statements.
  #
  # @api public
  def ===(value); end

  # Creates a compound `and` expectation. The matcher will
  # only pass if both sub-matchers pass.
  # This can be chained together to form an arbitrarily long
  # chain of matchers.
  #
  # @api public
  # @example
  #   expect(alphabet).to start_with("a").and end_with("z")
  #   expect(alphabet).to start_with("a") & end_with("z")
  # @note The negative form (`expect(...).not_to matcher.and other`)
  #   is not supported at this time.
  def and(matcher); end

  # Creates a compound `or` expectation. The matcher will
  # pass if either sub-matcher passes.
  # This can be chained together to form an arbitrarily long
  # chain of matchers.
  #
  # @api public
  # @example
  #   expect(stoplight.color).to eq("red").or eq("green").or eq("yellow")
  #   expect(stoplight.color).to eq("red") | eq("green") | eq("yellow")
  # @note The negative form (`expect(...).not_to matcher.or other`)
  #   is not supported at this time.
  def or(matcher); end

  # Creates a compound `or` expectation. The matcher will
  # pass if either sub-matcher passes.
  # This can be chained together to form an arbitrarily long
  # chain of matchers.
  #
  # @api public
  # @example
  #   expect(stoplight.color).to eq("red").or eq("green").or eq("yellow")
  #   expect(stoplight.color).to eq("red") | eq("green") | eq("yellow")
  # @note The negative form (`expect(...).not_to matcher.or other`)
  #   is not supported at this time.
  def |(matcher); end

  private

  # Returns the description of the given object in a way that is
  # aware of composed matchers. If the object is a matcher with
  # a `description` method, returns the description; otherwise
  # returns `object.inspect`.
  #
  # You are encouraged to use this in your custom matcher's
  # `description`, `failure_message` or
  # `failure_message_when_negated` implementation if you are
  # supporting matcher arguments.
  #
  # @api public
  def description_of(object); end

  # We should enumerate arrays as long as they are not recursive.
  #
  # @api private
  # @return [Boolean]
  def should_enumerate?(item); end

  # Transforms the given data structue (typically a hash or array)
  # into a new data structure that, when `#inspect` is called on it,
  # will provide descriptions of any contained matchers rather than
  # the normal `#inspect` output.
  #
  # You are encouraged to use this in your custom matcher's
  # `description`, `failure_message` or
  # `failure_message_when_negated` implementation if you are
  # supporting any arguments which may be a data structure
  # containing matchers.
  #
  # @api public
  def surface_descriptions_in(item); end

  # @api private
  # @return [Boolean]
  def unreadable_io?(object); end

  # This provides a generic way to fuzzy-match an expected value against
  # an actual value. It understands nested data structures (e.g. hashes
  # and arrays) and is able to match against a matcher being used as
  # the expected value or within the expected value at any level of
  # nesting.
  #
  # Within a custom matcher you are encouraged to use this whenever your
  # matcher needs to match two values, unless it needs more precise semantics.
  # For example, the `eq` matcher _does not_ use this as it is meant to
  # use `==` (and only `==`) for matching.
  #
  # @api public
  # @param expected [Object] what is expected
  # @param actual [Object] the actual value
  # @return [Boolean]
  def values_match?(expected, actual); end

  # Historically, a single matcher instance was only checked
  # against a single value. Given that the matcher was only
  # used once, it's been common to memoize some intermediate
  # calculation that is derived from the `actual` value in
  # order to reuse that intermediate result in the failure
  # message.
  #
  # This can cause a problem when using such a matcher as an
  # argument to another matcher in a composed matcher expression,
  # since the matcher instance may be checked against multiple
  # values and produce invalid results due to the memoization.
  #
  # To deal with this, we clone any matchers in `expected` via
  # this method when using `values_match?`, so that any memoization
  # does not "leak" between checks.
  #
  # @api public
  # @private
  def with_matchers_cloned(object); end

  class << self
    # We should enumerate arrays as long as they are not recursive.
    #
    # @api private
    # @return [Boolean]
    def should_enumerate?(item); end

    # Transforms the given data structue (typically a hash or array)
    # into a new data structure that, when `#inspect` is called on it,
    # will provide descriptions of any contained matchers rather than
    # the normal `#inspect` output.
    #
    # You are encouraged to use this in your custom matcher's
    # `description`, `failure_message` or
    # `failure_message_when_negated` implementation if you are
    # supporting any arguments which may be a data structure
    # containing matchers.
    #
    # @api public
    def surface_descriptions_in(item); end

    # @api private
    # @return [Boolean]
    def unreadable_io?(object); end
  end
end

# Wraps an item in order to surface its `description` via `inspect`.
#
# @api private
class RSpec::Matchers::Composable::DescribableItem < ::Struct
  # Inspectable version of the item description
  #
  # @api private
  def inspect; end

  # Returns the value of attribute item
  #
  # @return [Object] the current value of item
  def item; end

  # Sets the attribute item
  #
  # @param value [Object] the value to set the attribute item to.
  # @return [Object] the newly set value
  def item=(_); end

  # A pretty printed version of the item description.
  #
  # @api private
  def pretty_print(pp); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Defines the custom matcher DSL.
module RSpec::Matchers::DSL
  # Defines a matcher alias. The returned matcher's `description` will be overriden
  # to reflect the phrasing of the new name, which will be used in failure messages
  # when passed as an argument to another matcher in a composed matcher expression.
  #
  # @example
  #   RSpec::Matchers.alias_matcher :a_list_sorted_by, :be_sorted_by do |description|
  #   description.sub("be sorted by", "a list sorted by")
  #   end
  #
  #   be_sorted_by(:age).description # => "be sorted by age"
  #   a_list_sorted_by(:age).description # => "a list sorted by age"
  # @example
  #   RSpec::Matchers.alias_matcher :a_list_that_sums_to, :sum_to
  #   sum_to(3).description # => "sum to 3"
  #   a_list_that_sums_to(3).description # => "a list that sums to 3"
  # @option options
  # @param old_name [Symbol] the original name for the matcher
  # @param new_name [Symbol] the new name for the matcher
  # @param options [Hash] options for the aliased matcher
  # @see RSpec::Matchers
  # @yield [String] optional block that, when given, is used to define the overriden
  #   logic. The yielded arg is the original description or failure message. If no
  #   block is provided, a default override is used based on the old and new names.
  def alias_matcher(new_name, old_name, options = T.unsafe(nil), &description_override); end

  # Defines a custom matcher.
  #
  # @param name [Symbol] the name for the matcher
  # @see RSpec::Matchers
  # @yield [Object] block that is used to define the matcher.
  #   The block is evaluated in the context of your custom matcher class.
  #   When args are passed to your matcher, they will be yielded here,
  #   usually representing the expected value(s).
  def define(name, &declarations); end

  # Defines a negated matcher. The returned matcher's `description` and `failure_message`
  # will be overriden to reflect the phrasing of the new name, and the match logic will
  # be based on the original matcher but negated.
  #
  # @example
  #   RSpec::Matchers.define_negated_matcher :exclude, :include
  #   include(1, 2).description # => "include 1 and 2"
  #   exclude(1, 2).description # => "exclude 1 and 2"
  # @param negated_name [Symbol] the name for the negated matcher
  # @param base_name [Symbol] the name of the original matcher that will be negated
  # @see RSpec::Matchers
  # @yield [String] optional block that, when given, is used to define the overriden
  #   logic. The yielded arg is the original description or failure message. If no
  #   block is provided, a default override is used based on the old and new names.
  def define_negated_matcher(negated_name, base_name, &description_override); end

  # Defines a custom matcher.
  #
  # @param name [Symbol] the name for the matcher
  # @see RSpec::Matchers
  # @yield [Object] block that is used to define the matcher.
  #   The block is evaluated in the context of your custom matcher class.
  #   When args are passed to your matcher, they will be yielded here,
  #   usually representing the expected value(s).
  def matcher(name, &declarations); end

  private

  # :nocov:
  def warn_about_block_args(name, declarations); end
end

# Defines default implementations of the matcher
# protocol methods for custom matchers. You can
# override any of these using the {RSpec::Matchers::DSL::Macros Macros} methods
# from within an `RSpec::Matchers.define` block.
module RSpec::Matchers::DSL::DefaultImplementations
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages

  # The default description.
  def description; end

  # Used internally by objects returns by `should` and `should_not`.
  #
  # @api private
  # @return [Boolean]
  def diffable?; end

  # Most matchers do not expect call stack jumps.
  #
  # @return [Boolean]
  def expects_call_stack_jump?; end

  # Matchers do not support block expectations by default. You
  # must opt-in.
  #
  # @return [Boolean]
  def supports_block_expectations?; end

  # @return [Boolean]
  def supports_value_expectations?; end

  private

  def chained_method_clause_sentences; end
end

# Contains the methods that are available from within the
# `RSpec::Matchers.define` DSL for creating custom matchers.
module RSpec::Matchers::DSL::Macros
  # Convenience for defining methods on this matcher to create a fluent
  # interface. The trick about fluent interfaces is that each method must
  # return self in order to chain methods together. `chain` handles that
  # for you. If the method is invoked and the
  # `include_chain_clauses_in_custom_matcher_descriptions` config option
  # hash been enabled, the chained method name and args will be added to the
  # default description and failure message.
  #
  # In the common case where you just want the chained method to store some
  # value(s) for later use (e.g. in `match`), you can provide one or more
  # attribute names instead of a block; the chained method will store its
  # arguments in instance variables with those names, and the values will
  # be exposed via getters.
  #
  # @example
  #
  #   RSpec::Matchers.define :have_errors_on do |key|
  #   chain :with do |message|
  #   @message = message
  #   end
  #
  #   match do |actual|
  #   actual.errors[key] == @message
  #   end
  #   end
  #
  #   expect(minor).to have_errors_on(:age).with("Not old enough to participate")
  def chain(method_name, *attr_names, &definition); end

  # Customize the description to use for one-liners.  Only use this when
  # the description generated by default doesn't suit your needs.
  #
  # @example
  #
  #   RSpec::Matchers.define :qualify_for do |expected|
  #   match { your_match_logic }
  #
  #   description do
  #   "qualify for #{expected}"
  #   end
  #   end
  # @yield [Object] actual the actual object (i.e. the value wrapped by `expect`)
  def description(&definition); end

  # Tells the matcher to diff the actual and expected values in the failure
  # message.
  def diffable; end

  # Customizes the failure messsage to use when this matcher is
  # asked to positively match. Only use this when the message
  # generated by default doesn't suit your needs.
  #
  # @example
  #
  #   RSpec::Matchers.define :have_strength do |expected|
  #   match { your_match_logic }
  #
  #   failure_message do |actual|
  #   "Expected strength of #{expected}, but had #{actual.strength}"
  #   end
  #   end
  # @yield [Object] actual the actual object (i.e. the value wrapped by `expect`)
  def failure_message(&definition); end

  # Customize the failure messsage to use when this matcher is asked
  # to negatively match. Only use this when the message generated by
  # default doesn't suit your needs.
  #
  # @example
  #
  #   RSpec::Matchers.define :have_strength do |expected|
  #   match { your_match_logic }
  #
  #   failure_message_when_negated do |actual|
  #   "Expected not to have strength of #{expected}, but did"
  #   end
  #   end
  # @yield [Object] actual the actual object (i.e. the value wrapped by `expect`)
  def failure_message_when_negated(&definition); end

  # Stores the block that is used to determine whether this matcher passes
  # or fails. The block should return a boolean value. When the matcher is
  # passed to `expect(...).to` and the block returns `true`, then the expectation
  # passes. Similarly, when the matcher is passed to `expect(...).not_to` and the
  # block returns `false`, then the expectation passes.
  #
  # By default the match block will swallow expectation errors (e.g.
  # caused by using an expectation such as `expect(1).to eq 2`), if you
  # with to allow these to bubble up, pass in the option
  # `:notify_expectation_failures => true`.
  #
  # @example
  #
  #   RSpec::Matchers.define :be_even do
  #   match do |actual|
  #   actual.even?
  #   end
  #   end
  #
  #   expect(4).to be_even     # passes
  #   expect(3).not_to be_even # passes
  #   expect(3).to be_even     # fails
  #   expect(4).not_to be_even # fails
  # @param options [Hash] for defining the behavior of the match block.
  # @yield [Object] actual the actual value (i.e. the value wrapped by `expect`)
  def match(options = T.unsafe(nil), &match_block); end

  # Use this instead of `match` when the block will raise an exception
  # rather than returning false to indicate a failure.
  #
  # @example
  #
  #   RSpec::Matchers.define :accept_as_valid do |candidate_address|
  #   match_unless_raises ValidationException do |validator|
  #   validator.validate(candidate_address)
  #   end
  #   end
  #
  #   expect(email_validator).to accept_as_valid("person@company.com")
  # @yield [Object] actual the actual object (i.e. the value wrapped by `expect`)
  def match_unless_raises(expected_exception = T.unsafe(nil), &match_block); end

  # Use this to define the block for a negative expectation (`expect(...).not_to`)
  # when the positive and negative forms require different handling. This
  # is rarely necessary, but can be helpful, for example, when specifying
  # asynchronous processes that require different timeouts.
  #
  # By default the match block will swallow expectation errors (e.g.
  # caused by using an expectation such as `expect(1).to eq 2`), if you
  # with to allow these to bubble up, pass in the option
  # `:notify_expectation_failures => true`.
  #
  # @param options [Hash] for defining the behavior of the match block.
  # @yield [Object] actual the actual value (i.e. the value wrapped by `expect`)
  def match_when_negated(options = T.unsafe(nil), &match_block); end

  # Declares that the matcher can be used in a block expectation.
  # Users will not be able to use your matcher in a block
  # expectation without declaring this.
  # (e.g. `expect { do_something }.to matcher`).
  def supports_block_expectations; end

  private

  def assign_attributes(attr_names); end

  # Does the following:
  #
  # - Defines the named method using a user-provided block
  #   in @user_method_defs, which is included as an ancestor
  #   in the singleton class in which we eval the `define` block.
  # - Defines an overriden definition for the same method
  #   usign the provided `our_def` block.
  # - Provides a default `our_def` block for the common case
  #   of needing to call the user's definition with `@actual`
  #   as an arg, but only if their block's arity can handle it.
  #
  # This compiles the user block into an actual method, allowing
  # them to use normal method constructs like `return`
  # (e.g. for an early guard statement), while allowing us to define
  # an override that can provide the wrapped handling
  # (e.g. assigning `@actual`, rescueing errors, etc) and
  # can `super` to the user's definition.
  def define_user_override(method_name, user_def, &our_def); end
end

# Defines deprecated macro methods from RSpec 2 for backwards compatibility.
#
# @deprecated Use the methods from {Macros} instead.
module RSpec::Matchers::DSL::Macros::Deprecated
  # @deprecated Use {Macros#failure_message} instead.
  def failure_message_for_should(&definition); end

  # @deprecated Use {Macros#failure_message_when_negated} instead.
  def failure_message_for_should_not(&definition); end

  # @deprecated Use {Macros#match} instead.
  def match_for_should(&definition); end

  # @deprecated Use {Macros#match_when_negated} instead.
  def match_for_should_not(&definition); end
end

# @private
RSpec::Matchers::DSL::Macros::RAISE_NOTIFIER = T.let(T.unsafe(nil), Proc)

# The class used for custom matchers. The block passed to
# `RSpec::Matchers.define` will be evaluated in the context
# of the singleton class of an instance, and will have the
# {RSpec::Matchers::DSL::Macros Macros} methods available.
class RSpec::Matchers::DSL::Matcher
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  include ::RSpec::Matchers::DSL::DefaultImplementations
  include ::RSpec::Matchers
  include ::RSpec::Matchers::Composable
  extend ::RSpec::Matchers::DSL::Macros
  extend ::RSpec::Matchers::DSL::Macros::Deprecated

  # @api private
  # @return [Matcher] a new instance of Matcher
  def initialize(name, declarations, matcher_execution_context, *expected, &block_arg); end

  # Exposes the value being matched against -- generally the object
  # object wrapped by `expect`.
  def actual; end

  # The block parameter used in the expectation
  def block_arg; end

  # Provides the expected value. This will return an array if
  # multiple arguments were passed to the matcher; otherwise it
  # will return a single value.
  #
  # @see #expected_as_array
  def expected; end

  # Returns the expected value as an an array. This exists primarily
  # to aid in upgrading from RSpec 2.x, since in RSpec 2, `expected`
  # always returned an array.
  #
  # @see #expected
  def expected_as_array; end

  # Adds the name (rather than a cryptic hex number)
  # so we can identify an instance of
  # the matcher in error messages (e.g. for `NoMethodError`)
  def inspect; end

  # The name of the matcher.
  def name; end

  # Exposes the exception raised during the matching by `match_unless_raises`.
  # Could be useful to extract details for a failure message.
  def rescued_exception; end

  private

  def actual_arg_for(block); end

  # Takes care of forwarding unhandled messages to the
  # `@matcher_execution_context` (typically the current
  # running `RSpec::Core::Example`). This is needed by
  # rspec-rails so that it can define matchers that wrap
  # Rails' test helper methods, but it's also a useful
  # feature in its own right.
  def method_missing(method, *args, **_arg2, &block); end

  # Indicates that this matcher responds to messages
  # from the `@matcher_execution_context` as well.
  # Also, supports getting a method object for such methods.
  #
  # @return [Boolean]
  def respond_to_missing?(method, include_private = T.unsafe(nil)); end
end

RSpec::Matchers::DYNAMIC_MATCHER_REGEX = T.let(T.unsafe(nil), Regexp)

# Facilitates converting ruby objects to English phrases.
module RSpec::Matchers::EnglishPhrasing
  class << self
    # when given an empty list.
    #
    # Converts an object (often a collection of objects)
    # into an English list.
    #
    #     list(['banana', 'kiwi', 'mango'])
    #     #=> " \"banana\", \"kiwi\", and \"mango\""
    #
    # Given an empty collection, returns the empty string.
    #
    #     list([]) #=> ""
    #
    # @note The returned string has a leading space except
    def list(obj); end

    # Converts a symbol into an English expression.
    #
    #     split_words(:banana_creme_pie) #=> "banana creme pie"
    def split_words(sym); end
  end
end

# Handles list of expected values when there is a need to render
# multiple diffs. Also can handle one value.
#
# @api private
class RSpec::Matchers::ExpectedsForMultipleDiffs
  # @api private
  # @return [ExpectedsForMultipleDiffs] a new instance of ExpectedsForMultipleDiffs
  def initialize(expected_list); end

  # Returns message with diff(s) appended for provided differ
  # factory and actual value if there are any
  #
  # @api private
  # @param message [String] original failure message
  # @param differ [Proc]
  # @param actual [Any] value
  # @return [String]
  def message_with_diff(message, differ, actual); end

  private

  # @api private
  def diffs(differ, actual); end

  class << self
    # Wraps provided matcher list in instance of
    # ExpectedForMultipleDiffs.
    #
    # @api private
    # @param matchers [Array<Any>] list of matchers to wrap
    # @return [RSpec::Matchers::ExpectedsForMultipleDiffs]
    def for_many_matchers(matchers); end

    # Wraps provided expected value in instance of
    # ExpectedForMultipleDiffs. If provided value is already an
    # ExpectedForMultipleDiffs then it just returns it.
    #
    # @api private
    # @param expected [Any] value to be wrapped
    # @return [RSpec::Matchers::ExpectedsForMultipleDiffs]
    def from(expected); end

    private

    # @api private
    def diff_label_for(matcher); end

    # @api private
    def truncated(description); end
  end
end

# Default diff label when there is only one matcher in diff
# output
#
# @api private
# @private
RSpec::Matchers::ExpectedsForMultipleDiffs::DEFAULT_DIFF_LABEL = T.let(T.unsafe(nil), String)

# Maximum readable matcher description length
#
# @api private
# @private
RSpec::Matchers::ExpectedsForMultipleDiffs::DESCRIPTION_MAX_LENGTH = T.let(T.unsafe(nil), Integer)

RSpec::Matchers::HAS_REGEX = T.let(T.unsafe(nil), Regexp)

# Provides the necessary plumbing to wrap a matcher with a decorator.
#
# @private
class RSpec::Matchers::MatcherDelegator
  include ::RSpec::Matchers::Composable

  # @return [MatcherDelegator] a new instance of MatcherDelegator
  def initialize(base_matcher); end

  # Returns the value of attribute base_matcher.
  def base_matcher; end

  def method_missing(*args, &block); end

  private

  def initialize_copy(other); end

  # @return [Boolean]
  def respond_to_missing?(name, include_all = T.unsafe(nil)); end
end

# @private
RSpec::SharedContext = RSpec::Core::SharedContext
