# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: ignore
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/overcommit/all/overcommit.rbi
#
# overcommit-0.58.0

module Overcommit
end
module Overcommit::OS
  def self.cygwin?; end
  def self.host_os; end
  def self.linux?; end
  def self.mac?; end
  def self.unix?; end
  def self.windows?; end
end
module Overcommit::Exceptions
end
class Overcommit::Exceptions::Error < StandardError
end
class Overcommit::Exceptions::ConfigurationError < Overcommit::Exceptions::Error
end
class Overcommit::Exceptions::ConfigurationSignatureChanged < Overcommit::Exceptions::Error
end
class Overcommit::Exceptions::GitConfigError < Overcommit::Exceptions::Error
end
class Overcommit::Exceptions::GitSubmoduleError < Overcommit::Exceptions::Error
end
class Overcommit::Exceptions::GitRevListError < Overcommit::Exceptions::Error
end
class Overcommit::Exceptions::HookSetupFailed < Overcommit::Exceptions::Error
end
class Overcommit::Exceptions::HookCleanupFailed < Overcommit::Exceptions::Error
end
class Overcommit::Exceptions::HookCancelled < Overcommit::Exceptions::Error
end
class Overcommit::Exceptions::HookLoadError < Overcommit::Exceptions::Error
end
class Overcommit::Exceptions::HookContextLoadError < Overcommit::Exceptions::Error
end
class Overcommit::Exceptions::InvalidCommandArgs < Overcommit::Exceptions::Error
end
class Overcommit::Exceptions::InvalidGitRepo < Overcommit::Exceptions::Error
end
class Overcommit::Exceptions::InvalidHookDefinition < Overcommit::Exceptions::Error
end
class Overcommit::Exceptions::InvalidHookSignature < Overcommit::Exceptions::Error
end
class Overcommit::Exceptions::MessageProcessingError < Overcommit::Exceptions::Error
end
class Overcommit::Exceptions::PreExistingHooks < Overcommit::Exceptions::Error
end
class Overcommit::Subprocess
  def self.assign_output_streams(process); end
  def self.spawn(args, options = nil); end
  def self.spawn_detached(args); end
  def self.win32_prepare_args(args); end
end
class Overcommit::Subprocess::Result < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def status; end
  def status=(_); end
  def stderr; end
  def stderr=(_); end
  def stdout; end
  def stdout=(_); end
  def success?; end
end
module Overcommit::Utils
  def self.broken_symlink?(file); end
  def self.camel_case(str); end
  def self.convert_glob_to_absolute(glob); end
  def self.debug(*args); end
  def self.execute(initial_args, options = nil); end
  def self.execute_in_background(args); end
  def self.git_dir; end
  def self.in_path?(cmd); end
  def self.log; end
  def self.log=(arg0); end
  def self.matches_path?(pattern, path); end
  def self.parent_command; end
  def self.processor_count; end
  def self.repo_root; end
  def self.script_path(script); end
  def self.snake_case(str); end
  def self.strip_color_codes(text); end
  def self.supported_hook_type_classes; end
  def self.supported_hook_types; end
  def self.with_environment(env); end
end
module Overcommit::Utils::FileUtils
  def self.readlink(link_name); end
  def self.symlink(old_name, new_name); end
  def self.symlink?(file_name); end
  def self.win32_dir_cmd(file_name); end
  def self.win32_fix_pathsep(path); end
  def self.win32_mklink_cmd(old_name, new_name); end
  def self.win32_symlink?(dir_output); end
end
class Overcommit::CommandSplitter
  def self.arguments_under_limit(splittable_args, start_index, byte_limit); end
  def self.execute(initial_args, options); end
  def self.extract_argument_lists(args, splittable_args); end
  def self.max_command_length; end
end
class Overcommit::CommandSplitter::Result < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def status; end
  def statuses; end
  def statuses=(_); end
  def stderr; end
  def stderrs; end
  def stderrs=(_); end
  def stdout; end
  def stdouts; end
  def stdouts=(_); end
  def success?; end
end
class Overcommit::Utils::Version < Gem::Version
  def !=(version); end
  def <(version); end
  def <=(version); end
  def ==(version); end
  def >(version); end
  def >=(version); end
end
class Overcommit::ConfigurationValidator
  def check_for_missing_enabled_option(hash); end
  def check_for_too_many_processors(config, hash); end
  def check_for_verify_plugin_signatures_option(hash); end
  def check_hook_env(hash); end
  def check_hook_name_format(hash); end
  def convert_nils_to_empty_hashes(hash); end
  def ensure_hook_type_sections_exist(hash); end
  def validate(config, hash, options); end
end
class Overcommit::Configuration
  def ==(other); end
  def [](key); end
  def ad_hoc_hook?(hook_context, hook_name); end
  def all_builtin_hook_configs; end
  def all_hook_configs; end
  def all_plugin_hook_configs; end
  def apply_environment!(hook_context, env); end
  def built_in_hook?(hook_context, hook_name); end
  def concurrency; end
  def enabled_ad_hoc_hooks(hook_context); end
  def enabled_builtin_hooks(hook_context); end
  def for_hook(hook, hook_type = nil); end
  def hash; end
  def hook_enabled?(hook_context_or_type, hook_name); end
  def hook_exists?(hook_context, hook_name); end
  def initialize(hash, options = nil); end
  def merge(config); end
  def plugin_directory; end
  def plugin_hook?(hook_context_or_type, hook_name); end
  def previous_signature?; end
  def signature; end
  def signature_changed?; end
  def signature_config_key; end
  def smart_merge(parent, child); end
  def stored_signature; end
  def update_signature!; end
  def verify_signature_config_key; end
  def verify_signatures?; end
end
class Overcommit::ConfigurationLoader
  def initialize(logger, options = nil); end
  def load_file(file); end
  def load_repo_config; end
  def self.default_configuration; end
  def self.load_from_file(file, options = nil); end
  def verify_signatures(config); end
end
class Overcommit::MessageProcessor
  def basic_status_and_output(messages); end
  def can_upgrade_to_passing?(status, warning_messages); end
  def can_upgrade_to_warning?(status, error_messages); end
  def handle_modified_lines(messages, status); end
  def hook_result(messages); end
  def initialize(hook, unmodified_lines_setting); end
  def message_on_modified_line?(message); end
  def print_messages(messages, error_heading, warning_heading); end
  def remove_ignored_messages(messages); end
  def transform_status(status, messages_on_modified_lines); end
end
module Overcommit::Hook
end
class Overcommit::Hook::Message < Struct
  def content; end
  def content=(_); end
  def file; end
  def file=(_); end
  def line; end
  def line=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def to_s; end
  def type; end
  def type=(_); end
end
class Overcommit::Hook::Base
  def all_files(*args, ****, &block); end
  def applicable_file?(file); end
  def applicable_files; end
  def check_for_executable; end
  def check_for_libraries; end
  def check_for_requirements; end
  def command; end
  def config; end
  def current_branch; end
  def description; end
  def enabled?; end
  def exclude_branches; end
  def excluded?; end
  def execute(cmd, options = nil); end
  def execute_in_background(cmd); end
  def flags; end
  def in_path?(cmd); end
  def included_files; end
  def initialize(config, context); end
  def install_command_prompt; end
  def modified_files(*args, ****, &block); end
  def name; end
  def parallelize?; end
  def process_hook_return_value(hook_return_value); end
  def processors; end
  def quiet?; end
  def required?; end
  def required_executable; end
  def required_libraries; end
  def run; end
  def run?; end
  def run_and_transform; end
  def select_applicable(list); end
  def skip?; end
  def transform_status(status); end
  extend Forwardable
end
module Overcommit::HookContext
  def self.create(hook_type, config, args, input); end
end
class Overcommit::HookContext::Base
  def all_files; end
  def cleanup_environment; end
  def execute_hook(command); end
  def filter_directories(modified_files); end
  def filter_modified_files(modified_files); end
  def filter_nonexistent(modified_files); end
  def hook_class_name; end
  def hook_script_name; end
  def hook_type_name; end
  def initialize(config, args, input); end
  def input_lines; end
  def input_string; end
  def modified_files; end
  def post_fail_message; end
  def setup_environment; end
end
module Overcommit::GitConfig
  def comment_character; end
  def hooks_path; end
  def self.comment_character; end
  def self.hooks_path; end
end
module Overcommit::GitRepo
  def all_files; end
  def branches_containing_commit(commit_ref); end
  def current_branch; end
  def extract_modified_lines(file_path, options); end
  def initial_commit?; end
  def list_files(paths = nil, options = nil); end
  def modified_files(options); end
  def restore_cherry_pick_state; end
  def restore_merge_state; end
  def self.all_files; end
  def self.branches_containing_commit(commit_ref); end
  def self.current_branch; end
  def self.extract_modified_lines(file_path, options); end
  def self.initial_commit?; end
  def self.list_files(paths = nil, options = nil); end
  def self.modified_files(options); end
  def self.restore_cherry_pick_state; end
  def self.restore_merge_state; end
  def self.staged_submodule_removals; end
  def self.store_cherry_pick_state; end
  def self.store_merge_state; end
  def self.submodule_statuses(options = nil); end
  def self.submodules(options = nil); end
  def self.tracked?(path); end
  def staged_submodule_removals; end
  def store_cherry_pick_state; end
  def store_merge_state; end
  def submodule_statuses(options = nil); end
  def submodules(options = nil); end
  def tracked?(path); end
end
class Overcommit::GitRepo::SubmoduleStatus < Struct
  def describe; end
  def describe=(_); end
  def merge_conflict?; end
  def outdated?; end
  def path; end
  def path=(_); end
  def prefix; end
  def prefix=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def sha1; end
  def sha1=(_); end
  def uninitialized?; end
end
class Overcommit::GitRepo::Submodule < Struct
  def path; end
  def path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def url; end
  def url=(_); end
end
class Overcommit::HookSigner
  def hook_contents; end
  def hook_name; end
  def hook_path; end
  def initialize(hook_name, config, context); end
  def signable_file?(file); end
  def signature; end
  def signature_changed?; end
  def signature_config_key; end
  def stored_signature; end
  def update_signature!; end
end
module Overcommit::HookLoader
end
class Overcommit::HookLoader::Base
  def create_hook(hook_name); end
  def initialize(config, context, logger); end
  def load_hooks; end
  def log; end
end
class Overcommit::HookLoader::BuiltInHookLoader < Overcommit::HookLoader::Base
  def load_hooks; end
end
class Overcommit::HookLoader::PluginHookLoader < Overcommit::HookLoader::Base
  def ad_hoc_hook_names; end
  def check_for_modified_plugins; end
  def create_ad_hoc_hook(hook_name); end
  def load_hooks; end
  def modified_plugins; end
  def plugin_hook_names; end
  def plugin_paths; end
  def update_signatures; end
end
class InterruptHandler
  def initialize; end
  def isolate_signals; end
  def isolate_signals=(arg0); end
  def reenable_on_interrupt; end
  def reenable_on_interrupt=(arg0); end
  def self.allocate; end
  def self.disable!; end
  def self.disable_until_finished_or_interrupted; end
  def self.enable!; end
  def self.isolate_from_interrupts; end
  def self.new(*arg0, ****); end
  def signal_received; end
  def signal_received=(arg0); end
  extend Singleton::SingletonClassMethods
  include Singleton
end
class Overcommit::Printer
  def end_hook(hook, status, output); end
  def hook_run_failed(message); end
  def hook_script_name; end
  def hook_skipped(hook); end
  def initialize(config, logger, context); end
  def interrupt_triggered; end
  def log; end
  def nothing_to_run; end
  def print_header(hook); end
  def print_report(output, format = nil); end
  def print_result(hook, status, output); end
  def required_hook_not_skipped(hook); end
  def run_failed; end
  def run_interrupted; end
  def run_succeeded; end
  def run_warned; end
  def start_run; end
  def synchronize_all_methods; end
end
class Overcommit::HookRunner
  def consume; end
  def initialize(config, logger, context, printer); end
  def load_hooks; end
  def log; end
  def print_results; end
  def processors_for_hook(hook); end
  def release_slot(hook); end
  def run; end
  def run_hook(hook); end
  def run_hooks; end
  def should_skip?(hook); end
  def wait_for_slot(hook); end
end
class Overcommit::Installer
  def can_replace_file?(file); end
  def config(options = nil); end
  def ensure_directory(path); end
  def hooks_path; end
  def initialize(logger); end
  def install; end
  def install_hook_files; end
  def install_master_hook; end
  def install_starter_config; end
  def log; end
  def master_hook_install_path; end
  def old_hooks_path; end
  def overcommit_hook?(file); end
  def preserve_old_hooks; end
  def restore_old_hooks; end
  def run(target, options); end
  def uninstall; end
  def uninstall_hook_files; end
  def uninstall_master_hook; end
  def update; end
  def validate_target; end
end
class Overcommit::Logger
  def bold(*args); end
  def bold_error(*args); end
  def bold_warning(*args); end
  def color(code, str, partial = nil); end
  def debug(*args); end
  def error(*args); end
  def initialize(out); end
  def log(*args); end
  def newline; end
  def partial(*args); end
  def self.silent; end
  def success(*args); end
  def warning(*args); end
end
