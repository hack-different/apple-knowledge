# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: ignore
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/webrick/all/webrick.rbi
#
# webrick-1.7.0

module Errno
end
class Errno::EPROTO < SystemCallError
end
class Errno::ECONNRESET < SystemCallError
end
class Errno::ECONNABORTED < SystemCallError
end
module WEBrick
end
class WEBrick::HTTPVersion
  def <=>(other); end
  def initialize(version); end
  def major; end
  def major=(arg0); end
  def minor; end
  def minor=(arg0); end
  def self.convert(version); end
  def to_s; end
  include Comparable
end
module WEBrick::HTTPUtils
  def _escape(str, regex); end
  def _make_regex!(str); end
  def _make_regex(str); end
  def _unescape(str, regex); end
  def dequote(str); end
  def escape(str); end
  def escape8bit(str); end
  def escape_form(str); end
  def escape_path(str); end
  def load_mime_types(file); end
  def mime_type(filename, mime_tab); end
  def normalize_path(path); end
  def parse_form_data(io, boundary); end
  def parse_header(raw); end
  def parse_query(str); end
  def parse_qvalues(value); end
  def parse_range_header(ranges_specifier); end
  def quote(str); end
  def self._escape(str, regex); end
  def self._make_regex!(str); end
  def self._make_regex(str); end
  def self._unescape(str, regex); end
  def self.dequote(str); end
  def self.escape(str); end
  def self.escape8bit(str); end
  def self.escape_form(str); end
  def self.escape_path(str); end
  def self.load_mime_types(file); end
  def self.mime_type(filename, mime_tab); end
  def self.normalize_path(path); end
  def self.parse_form_data(io, boundary); end
  def self.parse_header(raw); end
  def self.parse_query(str); end
  def self.parse_qvalues(value); end
  def self.parse_range_header(ranges_specifier); end
  def self.quote(str); end
  def self.split_header_value(str); end
  def self.unescape(str); end
  def self.unescape_form(str); end
  def split_header_value(str); end
  def unescape(str); end
  def unescape_form(str); end
end
class WEBrick::HTTPUtils::FormData < String
  def <<(str); end
  def [](*key); end
  def append_data(data); end
  def each_data; end
  def filename; end
  def filename=(arg0); end
  def initialize(*args); end
  def list; end
  def name; end
  def name=(arg0); end
  def next_data; end
  def next_data=(arg0); end
  def to_ary; end
  def to_s; end
end
module WEBrick::Utils
  def create_listeners(address, port); end
  def getservername; end
  def random_string(len); end
  def self.create_listeners(address, port); end
  def self.getservername; end
  def self.random_string(len); end
  def self.set_close_on_exec(io); end
  def self.set_non_blocking(io); end
  def self.su(user); end
  def self.timeout(seconds, exception = nil); end
  def set_close_on_exec(io); end
  def set_non_blocking(io); end
  def su(user); end
  def timeout(seconds, exception = nil); end
end
class WEBrick::Utils::TimeoutHandler
  def cancel(thread, id); end
  def initialize; end
  def interrupt(thread, id, exception); end
  def register(thread, time, exception); end
  def self.allocate; end
  def self.cancel(id); end
  def self.new(*arg0, ****); end
  def self.register(seconds, exception); end
  def self.terminate; end
  def terminate; end
  def watch; end
  def watcher; end
  extend Singleton::SingletonClassMethods
  include Singleton
end
class WEBrick::BasicLog
  def <<(obj); end
  def close; end
  def debug(msg); end
  def debug?; end
  def error(msg); end
  def error?; end
  def fatal(msg); end
  def fatal?; end
  def format(arg); end
  def info(msg); end
  def info?; end
  def initialize(log_file = nil, level = nil); end
  def level; end
  def level=(arg0); end
  def log(level, data); end
  def warn(msg); end
  def warn?; end
end
class WEBrick::Log < WEBrick::BasicLog
  def initialize(log_file = nil, level = nil); end
  def log(level, data); end
  def time_format; end
  def time_format=(arg0); end
end
module WEBrick::Config
end
class WEBrick::ServerError < StandardError
end
class WEBrick::SimpleServer
  def self.start; end
end
class WEBrick::Daemon
  def self.start; end
end
class WEBrick::GenericServer
  def [](key); end
  def accept_client(svr); end
  def alarm_shutdown_pipe; end
  def call_callback(callback_name, *args); end
  def cleanup_listener; end
  def cleanup_shutdown_pipe(shutdown_pipe); end
  def config; end
  def initialize(config = nil, default = nil); end
  def listen(address, port); end
  def listeners; end
  def logger; end
  def run(sock); end
  def setup_shutdown_pipe; end
  def shutdown; end
  def start(&block); end
  def start_thread(sock, &block); end
  def status; end
  def stop; end
  def tokens; end
end
module WEBrick::AccessLog
  def escape(data); end
  def format(format_string, params); end
  def self.escape(data); end
  def self.format(format_string, params); end
  def self.setup_params(config, req, res); end
  def setup_params(config, req, res); end
end
class WEBrick::AccessLog::AccessLogError < StandardError
end
module WEBrick::HTMLUtils
  def escape(string); end
  def self.escape(string); end
end
class WEBrick::Cookie
  def comment; end
  def comment=(arg0); end
  def domain; end
  def domain=(arg0); end
  def expires; end
  def expires=(t); end
  def initialize(name, value); end
  def max_age; end
  def max_age=(arg0); end
  def name; end
  def path; end
  def path=(arg0); end
  def secure; end
  def secure=(arg0); end
  def self.parse(str); end
  def self.parse_set_cookie(str); end
  def self.parse_set_cookies(str); end
  def to_s; end
  def value; end
  def value=(arg0); end
  def version; end
  def version=(arg0); end
end
module WEBrick::HTTPStatus
  def client_error?(code); end
  def error?(code); end
  def info?(code); end
  def reason_phrase(code); end
  def redirect?(code); end
  def self.[](code); end
  def self.client_error?(code); end
  def self.error?(code); end
  def self.info?(code); end
  def self.reason_phrase(code); end
  def self.redirect?(code); end
  def self.server_error?(code); end
  def self.success?(code); end
  def server_error?(code); end
  def success?(code); end
end
class WEBrick::HTTPStatus::Status < StandardError
  def code; end
  def reason_phrase; end
  def self.code; end
  def self.reason_phrase; end
  def to_i; end
end
class WEBrick::HTTPStatus::Info < WEBrick::HTTPStatus::Status
end
class WEBrick::HTTPStatus::Success < WEBrick::HTTPStatus::Status
end
class WEBrick::HTTPStatus::Redirect < WEBrick::HTTPStatus::Status
end
class WEBrick::HTTPStatus::Error < WEBrick::HTTPStatus::Status
end
class WEBrick::HTTPStatus::ClientError < WEBrick::HTTPStatus::Error
end
class WEBrick::HTTPStatus::ServerError < WEBrick::HTTPStatus::Error
end
class WEBrick::HTTPStatus::EOFError < StandardError
end
class WEBrick::HTTPStatus::Continue < WEBrick::HTTPStatus::Info
end
class WEBrick::HTTPStatus::SwitchingProtocols < WEBrick::HTTPStatus::Info
end
class WEBrick::HTTPStatus::OK < WEBrick::HTTPStatus::Success
end
class WEBrick::HTTPStatus::Created < WEBrick::HTTPStatus::Success
end
class WEBrick::HTTPStatus::Accepted < WEBrick::HTTPStatus::Success
end
class WEBrick::HTTPStatus::NonAuthoritativeInformation < WEBrick::HTTPStatus::Success
end
class WEBrick::HTTPStatus::NoContent < WEBrick::HTTPStatus::Success
end
class WEBrick::HTTPStatus::ResetContent < WEBrick::HTTPStatus::Success
end
class WEBrick::HTTPStatus::PartialContent < WEBrick::HTTPStatus::Success
end
class WEBrick::HTTPStatus::MultiStatus < WEBrick::HTTPStatus::Success
end
class WEBrick::HTTPStatus::MultipleChoices < WEBrick::HTTPStatus::Redirect
end
class WEBrick::HTTPStatus::MovedPermanently < WEBrick::HTTPStatus::Redirect
end
class WEBrick::HTTPStatus::Found < WEBrick::HTTPStatus::Redirect
end
class WEBrick::HTTPStatus::SeeOther < WEBrick::HTTPStatus::Redirect
end
class WEBrick::HTTPStatus::NotModified < WEBrick::HTTPStatus::Redirect
end
class WEBrick::HTTPStatus::UseProxy < WEBrick::HTTPStatus::Redirect
end
class WEBrick::HTTPStatus::TemporaryRedirect < WEBrick::HTTPStatus::Redirect
end
class WEBrick::HTTPStatus::BadRequest < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::Unauthorized < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::PaymentRequired < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::Forbidden < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::NotFound < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::MethodNotAllowed < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::NotAcceptable < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::ProxyAuthenticationRequired < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::RequestTimeout < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::Conflict < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::Gone < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::LengthRequired < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::PreconditionFailed < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::RequestEntityTooLarge < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::RequestURITooLarge < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::UnsupportedMediaType < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::RequestRangeNotSatisfiable < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::ExpectationFailed < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::UnprocessableEntity < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::Locked < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::FailedDependency < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::UpgradeRequired < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::PreconditionRequired < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::TooManyRequests < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::RequestHeaderFieldsTooLarge < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::UnavailableForLegalReasons < WEBrick::HTTPStatus::ClientError
end
class WEBrick::HTTPStatus::InternalServerError < WEBrick::HTTPStatus::ServerError
end
class WEBrick::HTTPStatus::NotImplemented < WEBrick::HTTPStatus::ServerError
end
class WEBrick::HTTPStatus::BadGateway < WEBrick::HTTPStatus::ServerError
end
class WEBrick::HTTPStatus::ServiceUnavailable < WEBrick::HTTPStatus::ServerError
end
class WEBrick::HTTPStatus::GatewayTimeout < WEBrick::HTTPStatus::ServerError
end
class WEBrick::HTTPStatus::HTTPVersionNotSupported < WEBrick::HTTPStatus::ServerError
end
class WEBrick::HTTPStatus::InsufficientStorage < WEBrick::HTTPStatus::ServerError
end
class WEBrick::HTTPStatus::NetworkAuthenticationRequired < WEBrick::HTTPStatus::ServerError
end
class WEBrick::HTTPRequest
  def [](header_name); end
  def _read_data(io, method, *arg); end
  def accept; end
  def accept_charset; end
  def accept_encoding; end
  def accept_language; end
  def addr; end
  def attributes; end
  def body(&block); end
  def body_reader; end
  def content_length; end
  def content_type; end
  def continue; end
  def cookies; end
  def each; end
  def fixup; end
  def header; end
  def host; end
  def http_version; end
  def initialize(config); end
  def keep_alive; end
  def keep_alive?; end
  def meta_vars; end
  def parse(socket = nil); end
  def parse_query; end
  def parse_uri(str, scheme = nil); end
  def path; end
  def path_info; end
  def path_info=(arg0); end
  def peeraddr; end
  def port; end
  def query; end
  def query_string; end
  def query_string=(arg0); end
  def raw_header; end
  def read_body(socket, block); end
  def read_chunk_size(socket); end
  def read_chunked(socket, block); end
  def read_data(io, size); end
  def read_header(socket); end
  def read_line(io, size = nil); end
  def read_request_line(socket); end
  def readpartial(size, buf = nil); end
  def remote_ip; end
  def request_line; end
  def request_method; end
  def request_time; end
  def request_uri; end
  def script_name; end
  def script_name=(arg0); end
  def server_name; end
  def setup_forwarded_info; end
  def ssl?; end
  def to_s; end
  def unparsed_uri; end
  def user; end
  def user=(arg0); end
end
class WEBrick::HTTPResponse
  def [](field); end
  def []=(field, value); end
  def _write_data(socket, data); end
  def body; end
  def body=(arg0); end
  def check_header(header_value); end
  def chunked=(val); end
  def chunked?; end
  def config; end
  def content_length; end
  def content_length=(len); end
  def content_type; end
  def content_type=(type); end
  def cookies; end
  def each; end
  def error_body(backtrace, ex, host, port); end
  def filename; end
  def filename=(arg0); end
  def header; end
  def http_version; end
  def initialize(config); end
  def keep_alive; end
  def keep_alive=(arg0); end
  def keep_alive?; end
  def make_body_tempfile; end
  def reason_phrase; end
  def reason_phrase=(arg0); end
  def remove_body_tempfile; end
  def request_http_version; end
  def request_http_version=(arg0); end
  def request_method; end
  def request_method=(arg0); end
  def request_uri; end
  def request_uri=(arg0); end
  def send_body(socket); end
  def send_body_io(socket); end
  def send_body_proc(socket); end
  def send_body_string(socket); end
  def send_header(socket); end
  def send_response(socket); end
  def sent_size; end
  def set_error(ex, backtrace = nil); end
  def set_redirect(status, url); end
  def setup_header; end
  def status; end
  def status=(status); end
  def status_line; end
end
class WEBrick::HTTPResponse::InvalidHeader < StandardError
end
class WEBrick::HTTPResponse::ChunkedWrapper
  def <<(*buf); end
  def initialize(socket, resp); end
  def write(buf); end
end
module WEBrick::HTTPServlet
end
class WEBrick::HTTPServlet::HTTPServletError < StandardError
end
class WEBrick::HTTPServlet::AbstractServlet
  def do_GET(req, res); end
  def do_HEAD(req, res); end
  def do_OPTIONS(req, res); end
  def initialize(server, *options); end
  def redirect_to_directory_uri(req, res); end
  def self.get_instance(server, *options); end
  def service(req, res); end
end
class WEBrick::HTTPServlet::DefaultFileHandler < WEBrick::HTTPServlet::AbstractServlet
  def do_GET(req, res); end
  def initialize(server, local_path); end
  def make_partial_content(req, res, filename, filesize); end
  def multipart_body(body, parts, boundary, mtype, filesize); end
  def not_modified?(req, res, mtime, etag); end
  def prepare_range(range, filesize); end
end
class WEBrick::HTTPServlet::FileHandler < WEBrick::HTTPServlet::AbstractServlet
  def call_callback(callback_name, req, res); end
  def check_filename(req, res, name); end
  def do_GET(req, res); end
  def do_OPTIONS(req, res); end
  def do_POST(req, res); end
  def exec_handler(req, res); end
  def get_handler(req, res); end
  def initialize(server, root, options = nil, default = nil); end
  def nondisclosure_name?(name); end
  def prevent_directory_traversal(req, res); end
  def search_file(req, res, basename); end
  def search_index_file(req, res); end
  def self.add_handler(suffix, handler); end
  def self.remove_handler(suffix); end
  def service(req, res); end
  def set_dir_list(req, res); end
  def set_filename(req, res); end
  def set_filesystem_encoding(str); end
  def shift_path_info(req, res, path_info, base = nil); end
  def trailing_pathsep?(path); end
  def windows_ambiguous_name?(name); end
end
class WEBrick::HTTPServlet::CGIHandler < WEBrick::HTTPServlet::AbstractServlet
  def do_GET(req, res); end
  def do_POST(req, res); end
  def initialize(server, name); end
end
class WEBrick::HTTPServlet::ERBHandler < WEBrick::HTTPServlet::AbstractServlet
  def do_GET(req, res); end
  def do_POST(req, res); end
  def evaluate(erb, servlet_request, servlet_response); end
  def initialize(server, name); end
end
class WEBrick::HTTPServlet::ProcHandler < WEBrick::HTTPServlet::AbstractServlet
  def do_GET(request, response); end
  def do_POST(request, response); end
  def get_instance(server, *options); end
  def initialize(proc); end
end
class WEBrick::HTTPServerError < WEBrick::ServerError
end
class WEBrick::HTTPServer < WEBrick::GenericServer
  def access_log(config, req, res); end
  def create_request(with_webrick_config); end
  def create_response(with_webrick_config); end
  def do_OPTIONS(req, res); end
  def initialize(config = nil, default = nil); end
  def lookup_server(req); end
  def mount(dir, servlet, *options); end
  def mount_proc(dir, proc = nil, &block); end
  def run(sock); end
  def search_servlet(path); end
  def service(req, res); end
  def umount(dir); end
  def unmount(dir); end
  def virtual_host(server); end
end
class WEBrick::HTTPServer::MountTable
  def [](dir); end
  def []=(dir, val); end
  def compile; end
  def delete(dir); end
  def initialize; end
  def normalize(dir); end
  def scan(path); end
end
module WEBrick::HTTPAuth
  def _basic_auth(req, res, realm, req_field, res_field, err_type, block); end
  def basic_auth(req, res, realm, &block); end
  def proxy_basic_auth(req, res, realm, &block); end
  def self._basic_auth(req, res, realm, req_field, res_field, err_type, block); end
  def self.basic_auth(req, res, realm, &block); end
  def self.proxy_basic_auth(req, res, realm, &block); end
end
module WEBrick::HTTPAuth::Authenticator
  def check_init(config); end
  def check_scheme(req); end
  def error(fmt, *args); end
  def info(fmt, *args); end
  def log(meth, fmt, *args); end
  def logger; end
  def realm; end
  def userdb; end
end
module WEBrick::HTTPAuth::ProxyAuthenticator
end
class WEBrick::HTTPAuth::BasicAuth
  def authenticate(req, res); end
  def challenge(req, res); end
  def initialize(config, default = nil); end
  def logger; end
  def realm; end
  def self.make_passwd(realm, user, pass); end
  def userdb; end
  include WEBrick::HTTPAuth::Authenticator
end
class WEBrick::HTTPAuth::ProxyBasicAuth < WEBrick::HTTPAuth::BasicAuth
  include WEBrick::HTTPAuth::ProxyAuthenticator
end
class WEBrick::HTTPAuth::DigestAuth
  def _authenticate(req, res); end
  def algorithm; end
  def authenticate(req, res); end
  def challenge(req, res, stale = nil); end
  def check_nonce(req, auth_req); end
  def check_opaque(opaque_struct, req, auth_req); end
  def check_uri(req, auth_req); end
  def generate_next_nonce(req); end
  def generate_opaque(req); end
  def hexdigest(*args); end
  def initialize(config, default = nil); end
  def qop; end
  def self.make_passwd(realm, user, pass); end
  def split_param_value(string); end
  include WEBrick::HTTPAuth::Authenticator
end
class WEBrick::HTTPAuth::DigestAuth::OpaqueInfo < Struct
  def nc; end
  def nc=(_); end
  def nonce; end
  def nonce=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def time; end
  def time=(_); end
end
class WEBrick::HTTPAuth::ProxyDigestAuth < WEBrick::HTTPAuth::DigestAuth
  def check_uri(req, auth_req); end
  include WEBrick::HTTPAuth::ProxyAuthenticator
end
module WEBrick::HTTPAuth::UserDB
  def auth_type; end
  def auth_type=(arg0); end
  def get_passwd(realm, user, reload_db = nil); end
  def make_passwd(realm, user, pass); end
  def set_passwd(realm, user, pass); end
end
class WEBrick::HTTPAuth::Htpasswd
  def delete_passwd(realm, user); end
  def each; end
  def flush(output = nil); end
  def get_passwd(realm, user, reload_db); end
  def initialize(path, password_hash: nil); end
  def reload; end
  def set_passwd(realm, user, pass); end
  include WEBrick::HTTPAuth::UserDB
end
class WEBrick::HTTPAuth::Htdigest
  def delete_passwd(realm, user); end
  def each; end
  def flush(output = nil); end
  def get_passwd(realm, user, reload_db); end
  def initialize(path); end
  def reload; end
  def set_passwd(realm, user, pass); end
  include WEBrick::HTTPAuth::UserDB
end
class WEBrick::HTTPAuth::Htgroup
  def add(group, members); end
  def flush(output = nil); end
  def initialize(path); end
  def members(group); end
  def reload; end
end
